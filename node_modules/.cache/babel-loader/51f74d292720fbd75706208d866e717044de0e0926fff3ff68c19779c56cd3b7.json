{"ast":null,"code":"'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n  constructor(options) {\n    super(options);\n    this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    this.stage = 'init';\n    this.options = options || {};\n    this.secureConnection = !!this.options.secure;\n    this.alreadySecured = !!this.options.secured;\n    this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n    this.host = this.options.host || 'localhost';\n    this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;\n    this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n    if (typeof this.options.secure === 'undefined' && this.port === 465) {\n      // if secure option is not set but port is 465, then default to secure\n      this.secureConnection = true;\n    }\n    this.name = this.options.name || this._getHostname();\n    this.logger = shared.getLogger(this.options, {\n      component: this.options.component || 'smtp-connection',\n      sid: this.id\n    });\n    this.customAuth = new Map();\n    Object.keys(this.options.customAuth || {}).forEach(key => {\n      let mapKey = (key || '').toString().trim().toUpperCase();\n      if (!mapKey) {\n        return;\n      }\n      this.customAuth.set(mapKey, this.options.customAuth[key]);\n    });\n\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n    this.version = packageInfo.version;\n\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n    this.authenticated = false;\n\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n    this.secure = !!this.secureConnection;\n\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n    this._remainder = '';\n\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n    this._responseQueue = [];\n    this.lastServerResponse = false;\n\n    /**\n     * The socket connecting to the server\n     * @public\n     */\n    this._socket = false;\n\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n    this._supportedAuth = [];\n\n    /**\n     * Set to true, if EHLO response includes \"AUTH\".\n     * If false then authentication is not tried\n     */\n    this.allowsAuth = false;\n\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n    this._envelope = false;\n\n    /**\n     * Lists supported extensions\n     * @private\n     */\n    this._supportedExtensions = [];\n\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n    this._maxAllowedSize = 0;\n\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n    this._responseActions = [];\n    this._recipientQueue = [];\n\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n    this._greetingTimeout = false;\n\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n    this._connectionTimeout = false;\n\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n    this._destroyed = false;\n\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n    this._closing = false;\n\n    /**\n     * Callbacks for socket's listeners\n     */\n    this._onSocketData = chunk => this._onData(chunk);\n    this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n    this._onSocketClose = () => this._onClose();\n    this._onSocketEnd = () => this._onEnd();\n    this._onSocketTimeout = () => this._onTimeout();\n  }\n\n  /**\n   * Creates a connection to a SMTP server and sets up connection\n   * listener\n   */\n  connect(connectCallback) {\n    if (typeof connectCallback === 'function') {\n      this.once('connect', () => {\n        this.logger.debug({\n          tnx: 'smtp'\n        }, 'SMTP handshake finished');\n        connectCallback();\n      });\n      const isDestroyedMessage = this._isDestroyedMessage('connect');\n      if (isDestroyedMessage) {\n        return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n      }\n    }\n    let opts = {\n      port: this.port,\n      host: this.host,\n      allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n      timeout: this.options.dnsTimeout || DNS_TIMEOUT\n    };\n    if (this.options.localAddress) {\n      opts.localAddress = this.options.localAddress;\n    }\n    let setupConnectionHandlers = () => {\n      this._connectionTimeout = setTimeout(() => {\n        this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n      }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n      this._socket.on('error', this._onSocketError);\n    };\n    if (this.options.connection) {\n      // connection is already opened\n      this._socket = this.options.connection;\n      setupConnectionHandlers();\n      if (this.secureConnection && !this.alreadySecured) {\n        setImmediate(() => this._upgradeConnection(err => {\n          if (err) {\n            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n            return;\n          }\n          this._onConnect();\n        }));\n      } else {\n        setImmediate(() => this._onConnect());\n      }\n      return;\n    } else if (this.options.socket) {\n      // socket object is set up but not yet connected\n      this._socket = this.options.socket;\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket.connect(this.port, this.host, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else if (this.secureConnection) {\n      // connect using tls\n      if (this.options.tls) {\n        Object.keys(this.options.tls).forEach(key => {\n          opts[key] = this.options.tls[key];\n        });\n      }\n\n      // ensure servername for SNI\n      if (this.servername && !opts.servername) {\n        opts.servername = this.servername;\n      }\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket = tls.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    } else {\n      // connect using plaintext\n      return shared.resolveHostname(opts, (err, resolved) => {\n        if (err) {\n          return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n        }\n        this.logger.debug({\n          tnx: 'dns',\n          source: opts.host,\n          resolved: resolved.host,\n          cached: !!resolved.cached\n        }, 'Resolved %s as %s [cache %s]', opts.host, resolved.host, resolved.cached ? 'hit' : 'miss');\n        Object.keys(resolved).forEach(key => {\n          if (key.charAt(0) !== '_' && resolved[key]) {\n            opts[key] = resolved[key];\n          }\n        });\n        try {\n          this._socket = net.connect(opts, () => {\n            this._socket.setKeepAlive(true);\n            this._onConnect();\n          });\n          setupConnectionHandlers();\n        } catch (E) {\n          return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n        }\n      });\n    }\n  }\n\n  /**\n   * Sends QUIT\n   */\n  quit() {\n    this._sendCommand('QUIT');\n    this._responseActions.push(this.close);\n  }\n\n  /**\n   * Closes the connection to the server\n   */\n  close() {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    this._responseActions = [];\n\n    // allow to run this function only once\n    if (this._closing) {\n      return;\n    }\n    this._closing = true;\n    let closeMethod = 'end';\n    if (this.stage === 'init') {\n      // Close the socket immediately when connection timed out\n      closeMethod = 'destroy';\n    }\n    this.logger.debug({\n      tnx: 'smtp'\n    }, 'Closing connection to the server using \"%s\"', closeMethod);\n    let socket = this._socket && this._socket.socket || this._socket;\n    if (socket && !socket.destroyed) {\n      try {\n        socket[closeMethod]();\n      } catch (_E) {\n        // just ignore\n      }\n    }\n    this._destroy();\n  }\n\n  /**\n   * Authenticate user\n   */\n  login(authData, callback) {\n    const isDestroyedMessage = this._isDestroyedMessage('login');\n    if (isDestroyedMessage) {\n      return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    }\n    this._auth = authData || {};\n    // Select SASL authentication method\n    this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n    if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n      this._authMethod = 'XOAUTH2';\n    } else if (!this._authMethod || this._authMethod === 'XOAUTH2' && !this._auth.oauth2) {\n      // use first supported\n      this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n    }\n    if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n      if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {\n        this._auth.credentials = {\n          user: this._auth.user,\n          pass: this._auth.pass,\n          options: this._auth.options\n        };\n      } else {\n        return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n      }\n    }\n    if (this.customAuth.has(this._authMethod)) {\n      let handler = this.customAuth.get(this._authMethod);\n      let lastResponse;\n      let returned = false;\n      let resolve = () => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authenticated',\n          method: this._authMethod\n        }, 'User %s authenticated', JSON.stringify(this._auth.user));\n        this.authenticated = true;\n        callback(null, true);\n      };\n      let reject = err => {\n        if (returned) {\n          return;\n        }\n        returned = true;\n        callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n      };\n      let handlerResponse = handler({\n        auth: this._auth,\n        method: this._authMethod,\n        extensions: [].concat(this._supportedExtensions),\n        authMethods: [].concat(this._supportedAuth),\n        maxAllowedSize: this._maxAllowedSize || false,\n        sendCommand: (cmd, done) => {\n          let promise;\n          if (!done) {\n            promise = new Promise((resolve, reject) => {\n              done = shared.callbackPromise(resolve, reject);\n            });\n          }\n          this._responseActions.push(str => {\n            lastResponse = str;\n            let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n            let data = {\n              command: cmd,\n              response: str\n            };\n            if (codes) {\n              data.status = Number(codes[1]) || 0;\n              if (codes[2]) {\n                data.code = codes[2];\n              }\n              data.text = str.substr(codes[0].length);\n            } else {\n              data.text = str;\n              data.status = 0; // just in case we need to perform numeric comparisons\n            }\n            done(null, data);\n          });\n          setImmediate(() => this._sendCommand(cmd));\n          return promise;\n        },\n        resolve,\n        reject\n      });\n      if (handlerResponse && typeof handlerResponse.catch === 'function') {\n        // a promise was returned\n        handlerResponse.then(resolve).catch(reject);\n      }\n      return;\n    }\n    switch (this._authMethod) {\n      case 'XOAUTH2':\n        this._handleXOauth2Token(false, callback);\n        return;\n      case 'LOGIN':\n        this._responseActions.push(str => {\n          this._actionAUTH_LOGIN_USER(str, callback);\n        });\n        this._sendCommand('AUTH LOGIN');\n        return;\n      case 'PLAIN':\n        this._responseActions.push(str => {\n          this._actionAUTHComplete(str, callback);\n        });\n        this._sendCommand('AUTH PLAIN ' + Buffer.from(\n        //this._auth.user+'\\u0000'+\n        '\\u0000' +\n        // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + this._auth.credentials.pass, 'utf-8').toString('base64'),\n        // log entry without passwords\n        'AUTH PLAIN ' + Buffer.from(\n        //this._auth.user+'\\u0000'+\n        '\\u0000' +\n        // skip authorization identity as it causes problems with some servers\n        this._auth.credentials.user + '\\u0000' + '/* secret */', 'utf-8').toString('base64'));\n        return;\n      case 'CRAM-MD5':\n        this._responseActions.push(str => {\n          this._actionAUTH_CRAM_MD5(str, callback);\n        });\n        this._sendCommand('AUTH CRAM-MD5');\n        return;\n    }\n    return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n  }\n\n  /**\n   * Sends a message\n   *\n   * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n   * @param {Object} message String, Buffer or a Stream\n   * @param {Function} callback Callback to return once sending is completed\n   */\n  send(envelope, message, done) {\n    if (!message) {\n      return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n    }\n    const isDestroyedMessage = this._isDestroyedMessage('send message');\n    if (isDestroyedMessage) {\n      return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n    }\n\n    // reject larger messages than allowed\n    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n      return setImmediate(() => {\n        done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n      });\n    }\n\n    // ensure that callback is only called once\n    let returned = false;\n    let callback = function () {\n      if (returned) {\n        return;\n      }\n      returned = true;\n      done(...arguments);\n    };\n    if (typeof message.on === 'function') {\n      message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n    }\n    let startTime = Date.now();\n    this._setEnvelope(envelope, (err, info) => {\n      if (err) {\n        // create passthrough stream to consume to prevent OOM\n        let stream = new PassThrough();\n        if (typeof message.pipe === 'function') {\n          message.pipe(stream);\n        } else {\n          stream.write(message);\n          stream.end();\n        }\n        return callback(err);\n      }\n      let envelopeTime = Date.now();\n      let stream = this._createSendStream((err, str) => {\n        if (err) {\n          return callback(err);\n        }\n        info.envelopeTime = envelopeTime - startTime;\n        info.messageTime = Date.now() - envelopeTime;\n        info.messageSize = stream.outByteCount;\n        info.response = str;\n        return callback(null, info);\n      });\n      if (typeof message.pipe === 'function') {\n        message.pipe(stream);\n      } else {\n        stream.write(message);\n        stream.end();\n      }\n    });\n  }\n\n  /**\n   * Resets connection state\n   *\n   * @param {Function} callback Callback to return once connection is reset\n   */\n  reset(callback) {\n    this._sendCommand('RSET');\n    this._responseActions.push(str => {\n      if (str.charAt(0) !== '2') {\n        return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n      }\n      this._envelope = false;\n      return callback(null, true);\n    });\n  }\n\n  /**\n   * Connection listener that is run when the connection to\n   * the server is opened\n   *\n   * @event\n   */\n  _onConnect() {\n    clearTimeout(this._connectionTimeout);\n    this.logger.info({\n      tnx: 'network',\n      localAddress: this._socket.localAddress,\n      localPort: this._socket.localPort,\n      remoteAddress: this._socket.remoteAddress,\n      remotePort: this._socket.remotePort\n    }, '%s established to %s:%s', this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n    if (this._destroyed) {\n      // Connection was established after we already had canceled it\n      this.close();\n      return;\n    }\n    this.stage = 'connected';\n\n    // clear existing listeners for the socket\n    this._socket.removeListener('data', this._onSocketData);\n    this._socket.removeListener('timeout', this._onSocketTimeout);\n    this._socket.removeListener('close', this._onSocketClose);\n    this._socket.removeListener('end', this._onSocketEnd);\n    this._socket.on('data', this._onSocketData);\n    this._socket.once('close', this._onSocketClose);\n    this._socket.once('end', this._onSocketEnd);\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n    this._socket.on('timeout', this._onSocketTimeout);\n    this._greetingTimeout = setTimeout(() => {\n      // if still waiting for greeting, give up\n      if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n        this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n      }\n    }, this.options.greetingTimeout || GREETING_TIMEOUT);\n    this._responseActions.push(this._actionGreeting);\n\n    // we have a 'data' listener set up so resume socket if it was paused\n    this._socket.resume();\n  }\n\n  /**\n   * 'data' listener for data coming from the server\n   *\n   * @event\n   * @param {Buffer} chunk Data chunk coming from the server\n   */\n  _onData(chunk) {\n    if (this._destroyed || !chunk || !chunk.length) {\n      return;\n    }\n    let data = (chunk || '').toString('binary');\n    let lines = (this._remainder + data).split(/\\r?\\n/);\n    let lastline;\n    this._remainder = lines.pop();\n    for (let i = 0, len = lines.length; i < len; i++) {\n      if (this._responseQueue.length) {\n        lastline = this._responseQueue[this._responseQueue.length - 1];\n        if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n          this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n          continue;\n        }\n      }\n      this._responseQueue.push(lines[i]);\n    }\n    if (this._responseQueue.length) {\n      lastline = this._responseQueue[this._responseQueue.length - 1];\n      if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n        return;\n      }\n    }\n    this._processResponse();\n  }\n\n  /**\n   * 'error' listener for the socket\n   *\n   * @event\n   * @param {Error} err Error object\n   * @param {String} type Error name\n   */\n  _onError(err, type, data, command) {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    if (this._destroyed) {\n      // just ignore, already closed\n      // this might happen when a socket is canceled because of reached timeout\n      // but the socket timeout error itself receives only after\n      return;\n    }\n    err = this._formatError(err, type, data, command);\n    this.logger.error(data, err.message);\n    this.emit('error', err);\n    this.close();\n  }\n  _formatError(message, type, response, command) {\n    let err;\n    if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n      err = message;\n    } else {\n      err = new Error(message);\n    }\n    if (type && type !== 'Error') {\n      err.code = type;\n    }\n    if (response) {\n      err.response = response;\n      err.message += ': ' + response;\n    }\n    let responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n    if (responseCode) {\n      err.responseCode = responseCode;\n    }\n    if (command) {\n      err.command = command;\n    }\n    return err;\n  }\n\n  /**\n   * 'close' listener for the socket\n   *\n   * @event\n   */\n  _onClose() {\n    let serverResponse = false;\n    if (this._remainder && this._remainder.trim()) {\n      if (this.options.debug || this.options.transactionLog) {\n        this.logger.debug({\n          tnx: 'server'\n        }, this._remainder.replace(/\\r?\\n$/, ''));\n      }\n      this.lastServerResponse = serverResponse = this._remainder.trim();\n    }\n    this.logger.info({\n      tnx: 'network'\n    }, 'Connection closed');\n    if (this.upgrading && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', serverResponse, 'CONN');\n    } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n    } else if (/^[45]\\d{2}\\b/.test(serverResponse)) {\n      return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n    }\n    this._destroy();\n  }\n\n  /**\n   * 'end' listener for the socket\n   *\n   * @event\n   */\n  _onEnd() {\n    if (this._socket && !this._socket.destroyed) {\n      this._socket.destroy();\n    }\n  }\n\n  /**\n   * 'timeout' listener for the socket\n   *\n   * @event\n   */\n  _onTimeout() {\n    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n  }\n\n  /**\n   * Destroys the client, emits 'end'\n   */\n  _destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this.emit('end');\n  }\n\n  /**\n   * Upgrades the connection to TLS\n   *\n   * @param {Function} callback Callback function to run when the connection\n   *        has been secured\n   */\n  _upgradeConnection(callback) {\n    // do not remove all listeners or it breaks node v0.10 as there's\n    // apparently a 'finish' event set that would be cleared as well\n\n    // we can safely keep 'error', 'end', 'close' etc. events\n    this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n    this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n    let socketPlain = this._socket;\n    let opts = {\n      socket: this._socket,\n      host: this.host\n    };\n    Object.keys(this.options.tls || {}).forEach(key => {\n      opts[key] = this.options.tls[key];\n    });\n\n    // ensure servername for SNI\n    if (this.servername && !opts.servername) {\n      opts.servername = this.servername;\n    }\n    this.upgrading = true;\n    // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n    try {\n      this._socket = tls.connect(opts, () => {\n        this.secure = true;\n        this.upgrading = false;\n        this._socket.on('data', this._onSocketData);\n        socketPlain.removeListener('close', this._onSocketClose);\n        socketPlain.removeListener('end', this._onSocketEnd);\n        return callback(null, true);\n      });\n    } catch (err) {\n      return callback(err);\n    }\n    this._socket.on('error', this._onSocketError);\n    this._socket.once('close', this._onSocketClose);\n    this._socket.once('end', this._onSocketEnd);\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n    this._socket.on('timeout', this._onSocketTimeout);\n\n    // resume in case the socket was paused\n    socketPlain.resume();\n  }\n\n  /**\n   * Processes queued responses from the server\n   *\n   * @param {Boolean} force If true, ignores _processing flag\n   */\n  _processResponse() {\n    if (!this._responseQueue.length) {\n      return false;\n    }\n    let str = this.lastServerResponse = (this._responseQueue.shift() || '').toString();\n    if (/^\\d+-/.test(str.split('\\n').pop())) {\n      // keep waiting for the final part of multiline response\n      return;\n    }\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'server'\n      }, str.replace(/\\r?\\n$/, ''));\n    }\n    if (!str.trim()) {\n      // skip unexpected empty lines\n      setImmediate(() => this._processResponse());\n    }\n    let action = this._responseActions.shift();\n    if (typeof action === 'function') {\n      action.call(this, str);\n      setImmediate(() => this._processResponse());\n    } else {\n      return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n    }\n  }\n\n  /**\n   * Send a command to the server, append \\r\\n\n   *\n   * @param {String} str String to be sent to the server\n   * @param {String} logStr Optional string to be used for logging instead of the actual string\n   */\n  _sendCommand(str, logStr) {\n    if (this._destroyed) {\n      // Connection already closed, can't send any more data\n      return;\n    }\n    if (this._socket.destroyed) {\n      return this.close();\n    }\n    if (this.options.debug || this.options.transactionLog) {\n      this.logger.debug({\n        tnx: 'client'\n      }, (logStr || str || '').toString().replace(/\\r?\\n$/, ''));\n    }\n    this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n  }\n\n  /**\n   * Initiates a new message by submitting envelope data, starting with\n   * MAIL FROM: command\n   *\n   * @param {Object} envelope Envelope object in the form of\n   *        {from:'...', to:['...']}\n   *        or\n   *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n   */\n  _setEnvelope(envelope, callback) {\n    let args = [];\n    let useSmtpUtf8 = false;\n    this._envelope = envelope || {};\n    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n    this._envelope.to = [].concat(this._envelope.to || []).map(to => (to && to.address || to || '').toString().trim());\n    if (!this._envelope.to.length) {\n      return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n    }\n    if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n      return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n    }\n\n    // check if the sender address uses only ASCII characters,\n    // otherwise require usage of SMTPUTF8 extension\n    if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n      useSmtpUtf8 = true;\n    }\n    for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n      if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n        return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n      }\n\n      // check if the recipients addresses use only ASCII characters,\n      // otherwise require usage of SMTPUTF8 extension\n      if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n        useSmtpUtf8 = true;\n      }\n    }\n\n    // clone the recipients array for latter manipulation\n    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n    this._envelope.rejected = [];\n    this._envelope.rejectedErrors = [];\n    this._envelope.accepted = [];\n    if (this._envelope.dsn) {\n      try {\n        this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n      } catch (err) {\n        return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n      }\n    }\n    this._responseActions.push(str => {\n      this._actionMAIL(str, callback);\n    });\n\n    // If the server supports SMTPUTF8 and the envelope includes an internationalized\n    // email address then append SMTPUTF8 keyword to the MAIL FROM command\n    if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n      args.push('SMTPUTF8');\n      this._usingSmtpUtf8 = true;\n    }\n\n    // If the server supports 8BITMIME and the message might contain non-ascii bytes\n    // then append the 8BITMIME keyword to the MAIL FROM command\n    if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n      args.push('BODY=8BITMIME');\n      this._using8BitMime = true;\n    }\n    if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n      args.push('SIZE=' + this._envelope.size);\n    }\n\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the MAIL FROM command\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.ret) {\n        args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n      }\n      if (this._envelope.dsn.envid) {\n        args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n      }\n    }\n    this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n  }\n  _setDsnEnvelope(params) {\n    let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n    if (ret) {\n      switch (ret) {\n        case 'HDRS':\n        case 'HEADERS':\n          ret = 'HDRS';\n          break;\n        case 'FULL':\n        case 'BODY':\n          ret = 'FULL';\n          break;\n      }\n    }\n    if (ret && !['FULL', 'HDRS'].includes(ret)) {\n      throw new Error('ret: ' + JSON.stringify(ret));\n    }\n    let envid = (params.envid || params.id || '').toString() || null;\n    let notify = params.notify || null;\n    if (notify) {\n      if (typeof notify === 'string') {\n        notify = notify.split(',');\n      }\n      notify = notify.map(n => n.trim().toUpperCase());\n      let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n      let invaliNotify = notify.filter(n => !validNotify.includes(n));\n      if (invaliNotify.length || notify.length > 1 && notify.includes('NEVER')) {\n        throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n      }\n      notify = notify.join(',');\n    }\n    let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n    if (orcpt && orcpt.indexOf(';') < 0) {\n      orcpt = 'rfc822;' + orcpt;\n    }\n    return {\n      ret,\n      envid,\n      notify,\n      orcpt\n    };\n  }\n  _getDsnRcptToArgs() {\n    let args = [];\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the RCPT TO command\n    if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n      if (this._envelope.dsn.notify) {\n        args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n      }\n      if (this._envelope.dsn.orcpt) {\n        args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n      }\n    }\n    return args.length ? ' ' + args.join(' ') : '';\n  }\n  _createSendStream(callback) {\n    let dataStream = new DataStream();\n    let logStream;\n    if (this.options.lmtp) {\n      this._envelope.accepted.forEach((recipient, i) => {\n        let final = i === this._envelope.accepted.length - 1;\n        this._responseActions.push(str => {\n          this._actionLMTPStream(recipient, final, str, callback);\n        });\n      });\n    } else {\n      this._responseActions.push(str => {\n        this._actionSMTPStream(str, callback);\n      });\n    }\n    dataStream.pipe(this._socket, {\n      end: false\n    });\n    if (this.options.debug) {\n      logStream = new PassThrough();\n      logStream.on('readable', () => {\n        let chunk;\n        while (chunk = logStream.read()) {\n          this.logger.debug({\n            tnx: 'message'\n          }, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n        }\n      });\n      dataStream.pipe(logStream);\n    }\n    dataStream.once('end', () => {\n      this.logger.info({\n        tnx: 'message',\n        inByteCount: dataStream.inByteCount,\n        outByteCount: dataStream.outByteCount\n      }, '<%s bytes encoded mime message (source size %s bytes)>', dataStream.outByteCount, dataStream.inByteCount);\n    });\n    return dataStream;\n  }\n\n  /** ACTIONS **/\n\n  /**\n   * Will be run after the connection is created and the server sends\n   * a greeting. If the incoming message starts with 220 initiate\n   * SMTP session by sending EHLO command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionGreeting(str) {\n    clearTimeout(this._greetingTimeout);\n    if (str.substr(0, 3) !== '220') {\n      this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n      return;\n    }\n    if (this.options.lmtp) {\n      this._responseActions.push(this._actionLHLO);\n      this._sendCommand('LHLO ' + this.name);\n    } else {\n      this._responseActions.push(this._actionEHLO);\n      this._sendCommand('EHLO ' + this.name);\n    }\n  }\n\n  /**\n   * Handles server response for LHLO command. If it yielded in\n   * error, emit 'error', otherwise treat this as an EHLO response\n   *\n   * @param {String} str Message from the server\n   */\n  _actionLHLO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n      return;\n    }\n    this._actionEHLO(str);\n  }\n\n  /**\n   * Handles server response for EHLO command. If it yielded in\n   * error, try HELO instead, otherwise initiate TLS negotiation\n   * if STARTTLS is supported by the server or move into the\n   * authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionEHLO(str) {\n    let match;\n    if (str.substr(0, 3) === '421') {\n      this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n      return;\n    }\n    if (str.charAt(0) !== '2') {\n      if (this.options.requireTLS) {\n        this._onError(new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str), 'ECONNECTION', str, 'EHLO');\n        return;\n      }\n\n      // Try HELO instead\n      this._responseActions.push(this._actionHELO);\n      this._sendCommand('HELO ' + this.name);\n      return;\n    }\n    this._ehloLines = str.split(/\\r?\\n/).map(line => line.replace(/^\\d+[ -]/, '').trim()).filter(line => line).slice(1);\n\n    // Detect if the server supports STARTTLS\n    if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n      this._sendCommand('STARTTLS');\n      this._responseActions.push(this._actionSTARTTLS);\n      return;\n    }\n\n    // Detect if the server supports SMTPUTF8\n    if (/[ -]SMTPUTF8\\b/im.test(str)) {\n      this._supportedExtensions.push('SMTPUTF8');\n    }\n\n    // Detect if the server supports DSN\n    if (/[ -]DSN\\b/im.test(str)) {\n      this._supportedExtensions.push('DSN');\n    }\n\n    // Detect if the server supports 8BITMIME\n    if (/[ -]8BITMIME\\b/im.test(str)) {\n      this._supportedExtensions.push('8BITMIME');\n    }\n\n    // Detect if the server supports PIPELINING\n    if (/[ -]PIPELINING\\b/im.test(str)) {\n      this._supportedExtensions.push('PIPELINING');\n    }\n\n    // Detect if the server supports AUTH\n    if (/[ -]AUTH\\b/i.test(str)) {\n      this.allowsAuth = true;\n    }\n\n    // Detect if the server supports PLAIN auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n      this._supportedAuth.push('PLAIN');\n    }\n\n    // Detect if the server supports LOGIN auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n      this._supportedAuth.push('LOGIN');\n    }\n\n    // Detect if the server supports CRAM-MD5 auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n      this._supportedAuth.push('CRAM-MD5');\n    }\n\n    // Detect if the server supports XOAUTH2 auth\n    if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n      this._supportedAuth.push('XOAUTH2');\n    }\n\n    // Detect if the server supports SIZE extensions (and the max allowed size)\n    if (match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im)) {\n      this._supportedExtensions.push('SIZE');\n      this._maxAllowedSize = Number(match[1]) || 0;\n    }\n    this.emit('connect');\n  }\n\n  /**\n   * Handles server response for HELO command. If it yielded in\n   * error, emit 'error', otherwise move into the authentication phase.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionHELO(str) {\n    if (str.charAt(0) !== '2') {\n      this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n      return;\n    }\n\n    // assume that authentication is enabled (most probably is not though)\n    this.allowsAuth = true;\n    this.emit('connect');\n  }\n\n  /**\n   * Handles server response for STARTTLS command. If there's an error\n   * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n   * succeedes restart the EHLO\n   *\n   * @param {String} str Message from the server\n   */\n  _actionSTARTTLS(str) {\n    if (str.charAt(0) !== '2') {\n      if (this.options.opportunisticTLS) {\n        this.logger.info({\n          tnx: 'smtp'\n        }, 'Failed STARTTLS upgrade, continuing unencrypted');\n        return this.emit('connect');\n      }\n      this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n      return;\n    }\n    this._upgradeConnection((err, secured) => {\n      if (err) {\n        this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n        return;\n      }\n      this.logger.info({\n        tnx: 'smtp'\n      }, 'Connection upgraded with STARTTLS');\n      if (secured) {\n        // restart session\n        if (this.options.lmtp) {\n          this._responseActions.push(this._actionLHLO);\n          this._sendCommand('LHLO ' + this.name);\n        } else {\n          this._responseActions.push(this._actionEHLO);\n          this._sendCommand('EHLO ' + this.name);\n        }\n      } else {\n        this.emit('connect');\n      }\n    });\n  }\n\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n   * response needs to be base64 encoded username. We do not need\n   * exact match but settle with 334 response in general as some\n   * hosts invalidly use a longer message than VXNlcm5hbWU6\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_LOGIN_USER(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 VXNlcm5hbWU6'\n      callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n      return;\n    }\n    this._responseActions.push(str => {\n      this._actionAUTH_LOGIN_PASS(str, callback);\n    });\n    this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n  }\n\n  /**\n   * Handle the response for AUTH CRAM-MD5 command. We are expecting\n   * '334 <challenge string>'. Data to be sent as response needs to be\n   * base64 decoded challenge string, MD5 hashed using the password as\n   * a HMAC key, prefixed by the username and a space, and finally all\n   * base64 encoded again.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_CRAM_MD5(str, callback) {\n    let challengeMatch = str.match(/^334\\s+(.+)$/);\n    let challengeString = '';\n    if (!challengeMatch) {\n      return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    } else {\n      challengeString = challengeMatch[1];\n    }\n\n    // Decode from base64\n    let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n      hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n    hmacMD5.update(base64decoded);\n    let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n    this._responseActions.push(str => {\n      this._actionAUTH_CRAM_MD5_PASS(str, callback);\n    });\n    this._sendCommand(Buffer.from(prepended).toString('base64'),\n    // hidden hash for logs\n    Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64'));\n  }\n\n  /**\n   * Handles the response to CRAM-MD5 authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_CRAM_MD5_PASS(str, callback) {\n    if (!str.match(/^235\\s+/)) {\n      return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    }\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n\n  /**\n   * Handle the response for AUTH LOGIN command. We are expecting\n   * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n   * response needs to be base64 encoded password.\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTH_LOGIN_PASS(str, callback) {\n    if (!/^334[ -]/.test(str)) {\n      // expecting '334 UGFzc3dvcmQ6'\n      return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n    }\n    this._responseActions.push(str => {\n      this._actionAUTHComplete(str, callback);\n    });\n    this._sendCommand(Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n    // Hidden pass for logs\n    Buffer.from('/* secret */', 'utf-8').toString('base64'));\n  }\n\n  /**\n   * Handles the response for authentication, if there's no error,\n   * the user can be considered logged in. Start waiting for a message to send\n   *\n   * @param {String} str Message from the server\n   */\n  _actionAUTHComplete(str, isRetry, callback) {\n    if (!callback && typeof isRetry === 'function') {\n      callback = isRetry;\n      isRetry = false;\n    }\n    if (str.substr(0, 3) === '334') {\n      this._responseActions.push(str => {\n        if (isRetry || this._authMethod !== 'XOAUTH2') {\n          this._actionAUTHComplete(str, true, callback);\n        } else {\n          // fetch a new OAuth2 access token\n          setImmediate(() => this._handleXOauth2Token(true, callback));\n        }\n      });\n      this._sendCommand('');\n      return;\n    }\n    if (str.charAt(0) !== '2') {\n      this.logger.info({\n        tnx: 'smtp',\n        username: this._auth.user,\n        action: 'authfail',\n        method: this._authMethod\n      }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n      return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n    }\n    this.logger.info({\n      tnx: 'smtp',\n      username: this._auth.user,\n      action: 'authenticated',\n      method: this._authMethod\n    }, 'User %s authenticated', JSON.stringify(this._auth.user));\n    this.authenticated = true;\n    callback(null, true);\n  }\n\n  /**\n   * Handle response for a MAIL FROM: command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionMAIL(str, callback) {\n    let message, curRecipient;\n    if (Number(str.charAt(0)) !== 2) {\n      if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Mail command failed';\n      }\n      return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n    }\n    if (!this._envelope.rcptQueue.length) {\n      return callback(this._formatError(\"Can't send mail - no recipients defined\", 'EENVELOPE', false, 'API'));\n    } else {\n      this._recipientQueue = [];\n      if (this._supportedExtensions.includes('PIPELINING')) {\n        while (this._envelope.rcptQueue.length) {\n          curRecipient = this._envelope.rcptQueue.shift();\n          this._recipientQueue.push(curRecipient);\n          this._responseActions.push(str => {\n            this._actionRCPT(str, callback);\n          });\n          this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n      } else {\n        curRecipient = this._envelope.rcptQueue.shift();\n        this._recipientQueue.push(curRecipient);\n        this._responseActions.push(str => {\n          this._actionRCPT(str, callback);\n        });\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n      }\n    }\n  }\n\n  /**\n   * Handle response for a RCPT TO: command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionRCPT(str, callback) {\n    let message,\n      err,\n      curRecipient = this._recipientQueue.shift();\n    if (Number(str.charAt(0)) !== 2) {\n      // this is a soft error\n      if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n        message = 'Internationalized mailbox name not allowed';\n      } else {\n        message = 'Recipient command failed';\n      }\n      this._envelope.rejected.push(curRecipient);\n      // store error for the failed recipient\n      err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n      err.recipient = curRecipient;\n      this._envelope.rejectedErrors.push(err);\n    } else {\n      this._envelope.accepted.push(curRecipient);\n    }\n    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n      if (this._envelope.rejected.length < this._envelope.to.length) {\n        this._responseActions.push(str => {\n          this._actionDATA(str, callback);\n        });\n        this._sendCommand('DATA');\n      } else {\n        err = this._formatError(\"Can't send mail - all recipients were rejected\", 'EENVELOPE', str, 'RCPT TO');\n        err.rejected = this._envelope.rejected;\n        err.rejectedErrors = this._envelope.rejectedErrors;\n        return callback(err);\n      }\n    } else if (this._envelope.rcptQueue.length) {\n      curRecipient = this._envelope.rcptQueue.shift();\n      this._recipientQueue.push(curRecipient);\n      this._responseActions.push(str => {\n        this._actionRCPT(str, callback);\n      });\n      this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n    }\n  }\n\n  /**\n   * Handle response for a DATA command\n   *\n   * @param {String} str Message from the server\n   */\n  _actionDATA(str, callback) {\n    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n    if (!/^[23]/.test(str)) {\n      return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n    }\n    let response = {\n      accepted: this._envelope.accepted,\n      rejected: this._envelope.rejected\n    };\n    if (this._ehloLines && this._ehloLines.length) {\n      response.ehlo = this._ehloLines;\n    }\n    if (this._envelope.rejectedErrors.length) {\n      response.rejectedErrors = this._envelope.rejectedErrors;\n    }\n    callback(null, response);\n  }\n\n  /**\n   * Handle response for a DATA stream when using SMTP\n   * We expect a single response that defines if the sending succeeded or failed\n   *\n   * @param {String} str Message from the server\n   */\n  _actionSMTPStream(str, callback) {\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n    } else {\n      // Message sent succesfully\n      return callback(null, str);\n    }\n  }\n\n  /**\n   * Handle response for a DATA stream\n   * We expect a separate response for every recipient. All recipients can either\n   * succeed or fail separately\n   *\n   * @param {String} recipient The recipient this response applies to\n   * @param {Boolean} final Is this the final recipient?\n   * @param {String} str Message from the server\n   */\n  _actionLMTPStream(recipient, final, str, callback) {\n    let err;\n    if (Number(str.charAt(0)) !== 2) {\n      // Message failed\n      err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n      err.recipient = recipient;\n      this._envelope.rejected.push(recipient);\n      this._envelope.rejectedErrors.push(err);\n      for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n        if (this._envelope.accepted[i] === recipient) {\n          this._envelope.accepted.splice(i, 1);\n        }\n      }\n    }\n    if (final) {\n      return callback(null, str);\n    }\n  }\n  _handleXOauth2Token(isRetry, callback) {\n    this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n      if (err) {\n        this.logger.info({\n          tnx: 'smtp',\n          username: this._auth.user,\n          action: 'authfail',\n          method: this._authMethod\n        }, 'User %s failed to authenticate', JSON.stringify(this._auth.user));\n        return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n      }\n      this._responseActions.push(str => {\n        this._actionAUTHComplete(str, isRetry, callback);\n      });\n      this._sendCommand('AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n      //  Hidden for logs\n      'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */'));\n    });\n  }\n\n  /**\n   *\n   * @param {string} command\n   * @private\n   */\n  _isDestroyedMessage(command) {\n    if (this._destroyed) {\n      return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n    }\n    if (this._socket) {\n      if (this._socket.destroyed) {\n        return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n      }\n      if (!this._socket.writable) {\n        return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n      }\n    }\n  }\n  _getHostname() {\n    // defaul hostname is machine hostname or [IP]\n    let defaultHostname;\n    try {\n      defaultHostname = os.hostname() || '';\n    } catch (_err) {\n      // fails on windows 7\n      defaultHostname = 'localhost';\n    }\n\n    // ignore if not FQDN\n    if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n      defaultHostname = '[127.0.0.1]';\n    }\n\n    // IP should be enclosed in []\n    if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n      defaultHostname = '[' + defaultHostname + ']';\n    }\n    return defaultHostname;\n  }\n}\nmodule.exports = SMTPConnection;","map":{"version":3,"names":["packageInfo","require","EventEmitter","net","tls","os","crypto","DataStream","PassThrough","shared","CONNECTION_TIMEOUT","SOCKET_TIMEOUT","GREETING_TIMEOUT","DNS_TIMEOUT","SMTPConnection","constructor","options","id","randomBytes","toString","replace","stage","secureConnection","secure","alreadySecured","secured","port","Number","host","servername","isIP","allowInternalNetworkInterfaces","name","_getHostname","logger","getLogger","component","sid","customAuth","Map","Object","keys","forEach","key","mapKey","trim","toUpperCase","set","version","authenticated","destroyed","_remainder","_responseQueue","lastServerResponse","_socket","_supportedAuth","allowsAuth","_envelope","_supportedExtensions","_maxAllowedSize","_responseActions","_recipientQueue","_greetingTimeout","_connectionTimeout","_destroyed","_closing","_onSocketData","chunk","_onData","_onSocketError","error","_onError","_onSocketClose","_onClose","_onSocketEnd","_onEnd","_onSocketTimeout","_onTimeout","connect","connectCallback","once","debug","tnx","isDestroyedMessage","_isDestroyedMessage","_formatError","opts","timeout","dnsTimeout","localAddress","setupConnectionHandlers","setTimeout","connectionTimeout","on","connection","setImmediate","_upgradeConnection","err","Error","message","_onConnect","socket","resolveHostname","resolved","source","cached","charAt","setKeepAlive","E","quit","_sendCommand","push","close","clearTimeout","closeMethod","_E","_destroy","login","authData","callback","_auth","_authMethod","method","oauth2","credentials","user","pass","has","handler","get","lastResponse","returned","resolve","info","username","action","JSON","stringify","reject","handlerResponse","auth","extensions","concat","authMethods","maxAllowedSize","sendCommand","cmd","done","promise","Promise","callbackPromise","str","codes","match","data","command","response","status","code","text","substr","length","catch","then","_handleXOauth2Token","_actionAUTH_LOGIN_USER","_actionAUTHComplete","Buffer","from","_actionAUTH_CRAM_MD5","send","envelope","size","arguments","startTime","Date","now","_setEnvelope","stream","pipe","write","end","envelopeTime","_createSendStream","messageTime","messageSize","outByteCount","reset","localPort","remoteAddress","remotePort","removeListener","socketTimeout","_actionGreeting","greetingTimeout","resume","lines","split","lastline","pop","i","len","test","_processResponse","type","emit","prototype","call","responseCode","serverResponse","transactionLog","upgrading","includes","destroy","socketPlain","shift","logStr","args","useSmtpUtf8","address","to","map","rcptQueue","parse","rejected","rejectedErrors","accepted","dsn","_setDsnEnvelope","_actionMAIL","_usingSmtpUtf8","use8BitMime","_using8BitMime","ret","encodeXText","envid","join","params","return","notify","n","validNotify","invaliNotify","filter","orcpt","recipient","indexOf","_getDsnRcptToArgs","dataStream","logStream","lmtp","final","_actionLMTPStream","_actionSMTPStream","read","inByteCount","_actionLHLO","_actionEHLO","requireTLS","_actionHELO","_ehloLines","line","slice","ignoreTLS","_actionSTARTTLS","opportunisticTLS","_actionAUTH_LOGIN_PASS","challengeMatch","challengeString","base64decoded","hmacMD5","createHmac","update","prepended","digest","_actionAUTH_CRAM_MD5_PASS","isRetry","curRecipient","_actionRCPT","_actionDATA","ehlo","splice","getToken","accessToken","buildXOAuth2Token","writable","defaultHostname","hostname","_err","module","exports"],"sources":["D:/bank/banking-finance-system/node_modules/nodemailer/lib/smtp-connection/index.js"],"sourcesContent":["'use strict';\n\nconst packageInfo = require('../../package.json');\nconst EventEmitter = require('events').EventEmitter;\nconst net = require('net');\nconst tls = require('tls');\nconst os = require('os');\nconst crypto = require('crypto');\nconst DataStream = require('./data-stream');\nconst PassThrough = require('stream').PassThrough;\nconst shared = require('../shared');\n\n// default timeout values in ms\nconst CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nconst SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nconst GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\nconst DNS_TIMEOUT = 30 * 1000; // how much to wait for resolveHostname\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 587 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **dnsTimeout** - Time to wait in ms for the DNS requests to be resolved (defaults to 30 seconds)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nclass SMTPConnection extends EventEmitter {\n    constructor(options) {\n        super(options);\n\n        this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n        this.stage = 'init';\n\n        this.options = options || {};\n\n        this.secureConnection = !!this.options.secure;\n        this.alreadySecured = !!this.options.secured;\n\n        this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);\n        this.host = this.options.host || 'localhost';\n\n        this.servername = this.options.servername ? this.options.servername : !net.isIP(this.host) ? this.host : false;\n\n        this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;\n\n        if (typeof this.options.secure === 'undefined' && this.port === 465) {\n            // if secure option is not set but port is 465, then default to secure\n            this.secureConnection = true;\n        }\n\n        this.name = this.options.name || this._getHostname();\n\n        this.logger = shared.getLogger(this.options, {\n            component: this.options.component || 'smtp-connection',\n            sid: this.id\n        });\n\n        this.customAuth = new Map();\n        Object.keys(this.options.customAuth || {}).forEach(key => {\n            let mapKey = (key || '').toString().trim().toUpperCase();\n            if (!mapKey) {\n                return;\n            }\n            this.customAuth.set(mapKey, this.options.customAuth[key]);\n        });\n\n        /**\n         * Expose version nr, just for the reference\n         * @type {String}\n         */\n        this.version = packageInfo.version;\n\n        /**\n         * If true, then the user is authenticated\n         * @type {Boolean}\n         */\n        this.authenticated = false;\n\n        /**\n         * If set to true, this instance is no longer active\n         * @private\n         */\n        this.destroyed = false;\n\n        /**\n         * Defines if the current connection is secure or not. If not,\n         * STARTTLS can be used if available\n         * @private\n         */\n        this.secure = !!this.secureConnection;\n\n        /**\n         * Store incomplete messages coming from the server\n         * @private\n         */\n        this._remainder = '';\n\n        /**\n         * Unprocessed responses from the server\n         * @type {Array}\n         */\n        this._responseQueue = [];\n\n        this.lastServerResponse = false;\n\n        /**\n         * The socket connecting to the server\n         * @public\n         */\n        this._socket = false;\n\n        /**\n         * Lists supported auth mechanisms\n         * @private\n         */\n        this._supportedAuth = [];\n\n        /**\n         * Set to true, if EHLO response includes \"AUTH\".\n         * If false then authentication is not tried\n         */\n        this.allowsAuth = false;\n\n        /**\n         * Includes current envelope (from, to)\n         * @private\n         */\n        this._envelope = false;\n\n        /**\n         * Lists supported extensions\n         * @private\n         */\n        this._supportedExtensions = [];\n\n        /**\n         * Defines the maximum allowed size for a single message\n         * @private\n         */\n        this._maxAllowedSize = 0;\n\n        /**\n         * Function queue to run if a data chunk comes from the server\n         * @private\n         */\n        this._responseActions = [];\n        this._recipientQueue = [];\n\n        /**\n         * Timeout variable for waiting the greeting\n         * @private\n         */\n        this._greetingTimeout = false;\n\n        /**\n         * Timeout variable for waiting the connection to start\n         * @private\n         */\n        this._connectionTimeout = false;\n\n        /**\n         * If the socket is deemed already closed\n         * @private\n         */\n        this._destroyed = false;\n\n        /**\n         * If the socket is already being closed\n         * @private\n         */\n        this._closing = false;\n\n        /**\n         * Callbacks for socket's listeners\n         */\n        this._onSocketData = chunk => this._onData(chunk);\n        this._onSocketError = error => this._onError(error, 'ESOCKET', false, 'CONN');\n        this._onSocketClose = () => this._onClose();\n        this._onSocketEnd = () => this._onEnd();\n        this._onSocketTimeout = () => this._onTimeout();\n    }\n\n    /**\n     * Creates a connection to a SMTP server and sets up connection\n     * listener\n     */\n    connect(connectCallback) {\n        if (typeof connectCallback === 'function') {\n            this.once('connect', () => {\n                this.logger.debug(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'SMTP handshake finished'\n                );\n                connectCallback();\n            });\n\n            const isDestroyedMessage = this._isDestroyedMessage('connect');\n            if (isDestroyedMessage) {\n                return connectCallback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'CONN'));\n            }\n        }\n\n        let opts = {\n            port: this.port,\n            host: this.host,\n            allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,\n            timeout: this.options.dnsTimeout || DNS_TIMEOUT\n        };\n\n        if (this.options.localAddress) {\n            opts.localAddress = this.options.localAddress;\n        }\n\n        let setupConnectionHandlers = () => {\n            this._connectionTimeout = setTimeout(() => {\n                this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n            }, this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n            this._socket.on('error', this._onSocketError);\n        };\n\n        if (this.options.connection) {\n            // connection is already opened\n            this._socket = this.options.connection;\n            setupConnectionHandlers();\n\n            if (this.secureConnection && !this.alreadySecured) {\n                setImmediate(() =>\n                    this._upgradeConnection(err => {\n                        if (err) {\n                            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                            return;\n                        }\n                        this._onConnect();\n                    })\n                );\n            } else {\n                setImmediate(() => this._onConnect());\n            }\n            return;\n        } else if (this.options.socket) {\n            // socket object is set up but not yet connected\n            this._socket = this.options.socket;\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket.connect(this.port, this.host, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else if (this.secureConnection) {\n            // connect using tls\n            if (this.options.tls) {\n                Object.keys(this.options.tls).forEach(key => {\n                    opts[key] = this.options.tls[key];\n                });\n            }\n\n            // ensure servername for SNI\n            if (this.servername && !opts.servername) {\n                opts.servername = this.servername;\n            }\n\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = tls.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        } else {\n            // connect using plaintext\n            return shared.resolveHostname(opts, (err, resolved) => {\n                if (err) {\n                    return setImmediate(() => this._onError(err, 'EDNS', false, 'CONN'));\n                }\n                this.logger.debug(\n                    {\n                        tnx: 'dns',\n                        source: opts.host,\n                        resolved: resolved.host,\n                        cached: !!resolved.cached\n                    },\n                    'Resolved %s as %s [cache %s]',\n                    opts.host,\n                    resolved.host,\n                    resolved.cached ? 'hit' : 'miss'\n                );\n                Object.keys(resolved).forEach(key => {\n                    if (key.charAt(0) !== '_' && resolved[key]) {\n                        opts[key] = resolved[key];\n                    }\n                });\n                try {\n                    this._socket = net.connect(opts, () => {\n                        this._socket.setKeepAlive(true);\n                        this._onConnect();\n                    });\n                    setupConnectionHandlers();\n                } catch (E) {\n                    return setImmediate(() => this._onError(E, 'ECONNECTION', false, 'CONN'));\n                }\n            });\n        }\n    }\n\n    /**\n     * Sends QUIT\n     */\n    quit() {\n        this._sendCommand('QUIT');\n        this._responseActions.push(this.close);\n    }\n\n    /**\n     * Closes the connection to the server\n     */\n    close() {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n        this._responseActions = [];\n\n        // allow to run this function only once\n        if (this._closing) {\n            return;\n        }\n        this._closing = true;\n\n        let closeMethod = 'end';\n\n        if (this.stage === 'init') {\n            // Close the socket immediately when connection timed out\n            closeMethod = 'destroy';\n        }\n\n        this.logger.debug(\n            {\n                tnx: 'smtp'\n            },\n            'Closing connection to the server using \"%s\"',\n            closeMethod\n        );\n\n        let socket = (this._socket && this._socket.socket) || this._socket;\n\n        if (socket && !socket.destroyed) {\n            try {\n                socket[closeMethod]();\n            } catch (_E) {\n                // just ignore\n            }\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * Authenticate user\n     */\n    login(authData, callback) {\n        const isDestroyedMessage = this._isDestroyedMessage('login');\n        if (isDestroyedMessage) {\n            return callback(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        this._auth = authData || {};\n        // Select SASL authentication method\n        this._authMethod = (this._auth.method || '').toString().trim().toUpperCase() || false;\n\n        if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {\n            this._authMethod = 'XOAUTH2';\n        } else if (!this._authMethod || (this._authMethod === 'XOAUTH2' && !this._auth.oauth2)) {\n            // use first supported\n            this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n        }\n\n        if (this._authMethod !== 'XOAUTH2' && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {\n            if ((this._auth.user && this._auth.pass) || this.customAuth.has(this._authMethod)) {\n                this._auth.credentials = {\n                    user: this._auth.user,\n                    pass: this._auth.pass,\n                    options: this._auth.options\n                };\n            } else {\n                return callback(this._formatError('Missing credentials for \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n            }\n        }\n\n        if (this.customAuth.has(this._authMethod)) {\n            let handler = this.customAuth.get(this._authMethod);\n            let lastResponse;\n            let returned = false;\n\n            let resolve = () => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authenticated',\n                        method: this._authMethod\n                    },\n                    'User %s authenticated',\n                    JSON.stringify(this._auth.user)\n                );\n                this.authenticated = true;\n                callback(null, true);\n            };\n\n            let reject = err => {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n                callback(this._formatError(err, 'EAUTH', lastResponse, 'AUTH ' + this._authMethod));\n            };\n\n            let handlerResponse = handler({\n                auth: this._auth,\n                method: this._authMethod,\n\n                extensions: [].concat(this._supportedExtensions),\n                authMethods: [].concat(this._supportedAuth),\n                maxAllowedSize: this._maxAllowedSize || false,\n\n                sendCommand: (cmd, done) => {\n                    let promise;\n\n                    if (!done) {\n                        promise = new Promise((resolve, reject) => {\n                            done = shared.callbackPromise(resolve, reject);\n                        });\n                    }\n\n                    this._responseActions.push(str => {\n                        lastResponse = str;\n\n                        let codes = str.match(/^(\\d+)(?:\\s(\\d+\\.\\d+\\.\\d+))?\\s/);\n                        let data = {\n                            command: cmd,\n                            response: str\n                        };\n                        if (codes) {\n                            data.status = Number(codes[1]) || 0;\n                            if (codes[2]) {\n                                data.code = codes[2];\n                            }\n                            data.text = str.substr(codes[0].length);\n                        } else {\n                            data.text = str;\n                            data.status = 0; // just in case we need to perform numeric comparisons\n                        }\n                        done(null, data);\n                    });\n                    setImmediate(() => this._sendCommand(cmd));\n\n                    return promise;\n                },\n\n                resolve,\n                reject\n            });\n\n            if (handlerResponse && typeof handlerResponse.catch === 'function') {\n                // a promise was returned\n                handlerResponse.then(resolve).catch(reject);\n            }\n\n            return;\n        }\n\n        switch (this._authMethod) {\n            case 'XOAUTH2':\n                this._handleXOauth2Token(false, callback);\n                return;\n            case 'LOGIN':\n                this._responseActions.push(str => {\n                    this._actionAUTH_LOGIN_USER(str, callback);\n                });\n                this._sendCommand('AUTH LOGIN');\n                return;\n            case 'PLAIN':\n                this._responseActions.push(str => {\n                    this._actionAUTHComplete(str, callback);\n                });\n                this._sendCommand(\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                this._auth.credentials.pass,\n                            'utf-8'\n                        ).toString('base64'),\n                    // log entry without passwords\n                    'AUTH PLAIN ' +\n                        Buffer.from(\n                            //this._auth.user+'\\u0000'+\n                            '\\u0000' + // skip authorization identity as it causes problems with some servers\n                                this._auth.credentials.user +\n                                '\\u0000' +\n                                '/* secret */',\n                            'utf-8'\n                        ).toString('base64')\n                );\n                return;\n            case 'CRAM-MD5':\n                this._responseActions.push(str => {\n                    this._actionAUTH_CRAM_MD5(str, callback);\n                });\n                this._sendCommand('AUTH CRAM-MD5');\n                return;\n        }\n\n        return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n    }\n\n    /**\n     * Sends a message\n     *\n     * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n     * @param {Object} message String, Buffer or a Stream\n     * @param {Function} callback Callback to return once sending is completed\n     */\n    send(envelope, message, done) {\n        if (!message) {\n            return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n        }\n\n        const isDestroyedMessage = this._isDestroyedMessage('send message');\n        if (isDestroyedMessage) {\n            return done(this._formatError(isDestroyedMessage, 'ECONNECTION', false, 'API'));\n        }\n\n        // reject larger messages than allowed\n        if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n            return setImmediate(() => {\n                done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n            });\n        }\n\n        // ensure that callback is only called once\n        let returned = false;\n        let callback = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n\n            done(...arguments);\n        };\n\n        if (typeof message.on === 'function') {\n            message.on('error', err => callback(this._formatError(err, 'ESTREAM', false, 'API')));\n        }\n\n        let startTime = Date.now();\n        this._setEnvelope(envelope, (err, info) => {\n            if (err) {\n                // create passthrough stream to consume to prevent OOM\n                let stream = new PassThrough();\n                if (typeof message.pipe === 'function') {\n                    message.pipe(stream);\n                } else {\n                    stream.write(message);\n                    stream.end();\n                }\n\n                return callback(err);\n            }\n            let envelopeTime = Date.now();\n            let stream = this._createSendStream((err, str) => {\n                if (err) {\n                    return callback(err);\n                }\n\n                info.envelopeTime = envelopeTime - startTime;\n                info.messageTime = Date.now() - envelopeTime;\n                info.messageSize = stream.outByteCount;\n                info.response = str;\n\n                return callback(null, info);\n            });\n            if (typeof message.pipe === 'function') {\n                message.pipe(stream);\n            } else {\n                stream.write(message);\n                stream.end();\n            }\n        });\n    }\n\n    /**\n     * Resets connection state\n     *\n     * @param {Function} callback Callback to return once connection is reset\n     */\n    reset(callback) {\n        this._sendCommand('RSET');\n        this._responseActions.push(str => {\n            if (str.charAt(0) !== '2') {\n                return callback(this._formatError('Could not reset session state. response=' + str, 'EPROTOCOL', str, 'RSET'));\n            }\n            this._envelope = false;\n            return callback(null, true);\n        });\n    }\n\n    /**\n     * Connection listener that is run when the connection to\n     * the server is opened\n     *\n     * @event\n     */\n    _onConnect() {\n        clearTimeout(this._connectionTimeout);\n\n        this.logger.info(\n            {\n                tnx: 'network',\n                localAddress: this._socket.localAddress,\n                localPort: this._socket.localPort,\n                remoteAddress: this._socket.remoteAddress,\n                remotePort: this._socket.remotePort\n            },\n            '%s established to %s:%s',\n            this.secure ? 'Secure connection' : 'Connection',\n            this._socket.remoteAddress,\n            this._socket.remotePort\n        );\n\n        if (this._destroyed) {\n            // Connection was established after we already had canceled it\n            this.close();\n            return;\n        }\n\n        this.stage = 'connected';\n\n        // clear existing listeners for the socket\n        this._socket.removeListener('data', this._onSocketData);\n        this._socket.removeListener('timeout', this._onSocketTimeout);\n        this._socket.removeListener('close', this._onSocketClose);\n        this._socket.removeListener('end', this._onSocketEnd);\n\n        this._socket.on('data', this._onSocketData);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        this._greetingTimeout = setTimeout(() => {\n            // if still waiting for greeting, give up\n            if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n                this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n            }\n        }, this.options.greetingTimeout || GREETING_TIMEOUT);\n\n        this._responseActions.push(this._actionGreeting);\n\n        // we have a 'data' listener set up so resume socket if it was paused\n        this._socket.resume();\n    }\n\n    /**\n     * 'data' listener for data coming from the server\n     *\n     * @event\n     * @param {Buffer} chunk Data chunk coming from the server\n     */\n    _onData(chunk) {\n        if (this._destroyed || !chunk || !chunk.length) {\n            return;\n        }\n\n        let data = (chunk || '').toString('binary');\n        let lines = (this._remainder + data).split(/\\r?\\n/);\n        let lastline;\n\n        this._remainder = lines.pop();\n\n        for (let i = 0, len = lines.length; i < len; i++) {\n            if (this._responseQueue.length) {\n                lastline = this._responseQueue[this._responseQueue.length - 1];\n                if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                    this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                    continue;\n                }\n            }\n            this._responseQueue.push(lines[i]);\n        }\n\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+-/.test(lastline.split('\\n').pop())) {\n                return;\n            }\n        }\n\n        this._processResponse();\n    }\n\n    /**\n     * 'error' listener for the socket\n     *\n     * @event\n     * @param {Error} err Error object\n     * @param {String} type Error name\n     */\n    _onError(err, type, data, command) {\n        clearTimeout(this._connectionTimeout);\n        clearTimeout(this._greetingTimeout);\n\n        if (this._destroyed) {\n            // just ignore, already closed\n            // this might happen when a socket is canceled because of reached timeout\n            // but the socket timeout error itself receives only after\n            return;\n        }\n\n        err = this._formatError(err, type, data, command);\n\n        this.logger.error(data, err.message);\n\n        this.emit('error', err);\n        this.close();\n    }\n\n    _formatError(message, type, response, command) {\n        let err;\n\n        if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n            err = message;\n        } else {\n            err = new Error(message);\n        }\n\n        if (type && type !== 'Error') {\n            err.code = type;\n        }\n\n        if (response) {\n            err.response = response;\n            err.message += ': ' + response;\n        }\n\n        let responseCode = (typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0])) || false;\n        if (responseCode) {\n            err.responseCode = responseCode;\n        }\n\n        if (command) {\n            err.command = command;\n        }\n\n        return err;\n    }\n\n    /**\n     * 'close' listener for the socket\n     *\n     * @event\n     */\n    _onClose() {\n        let serverResponse = false;\n\n        if (this._remainder && this._remainder.trim()) {\n            if (this.options.debug || this.options.transactionLog) {\n                this.logger.debug(\n                    {\n                        tnx: 'server'\n                    },\n                    this._remainder.replace(/\\r?\\n$/, '')\n                );\n            }\n            this.lastServerResponse = serverResponse = this._remainder.trim();\n        }\n\n        this.logger.info(\n            {\n                tnx: 'network'\n            },\n            'Connection closed'\n        );\n\n        if (this.upgrading && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ETLS', serverResponse, 'CONN');\n        } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n        } else if (/^[45]\\d{2}\\b/.test(serverResponse)) {\n            return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', serverResponse, 'CONN');\n        }\n\n        this._destroy();\n    }\n\n    /**\n     * 'end' listener for the socket\n     *\n     * @event\n     */\n    _onEnd() {\n        if (this._socket && !this._socket.destroyed) {\n            this._socket.destroy();\n        }\n    }\n\n    /**\n     * 'timeout' listener for the socket\n     *\n     * @event\n     */\n    _onTimeout() {\n        return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n    }\n\n    /**\n     * Destroys the client, emits 'end'\n     */\n    _destroy() {\n        if (this._destroyed) {\n            return;\n        }\n        this._destroyed = true;\n        this.emit('end');\n    }\n\n    /**\n     * Upgrades the connection to TLS\n     *\n     * @param {Function} callback Callback function to run when the connection\n     *        has been secured\n     */\n    _upgradeConnection(callback) {\n        // do not remove all listeners or it breaks node v0.10 as there's\n        // apparently a 'finish' event set that would be cleared as well\n\n        // we can safely keep 'error', 'end', 'close' etc. events\n        this._socket.removeListener('data', this._onSocketData); // incoming data is going to be gibberish from this point onwards\n        this._socket.removeListener('timeout', this._onSocketTimeout); // timeout will be re-set for the new socket object\n\n        let socketPlain = this._socket;\n        let opts = {\n            socket: this._socket,\n            host: this.host\n        };\n\n        Object.keys(this.options.tls || {}).forEach(key => {\n            opts[key] = this.options.tls[key];\n        });\n\n        // ensure servername for SNI\n        if (this.servername && !opts.servername) {\n            opts.servername = this.servername;\n        }\n\n        this.upgrading = true;\n        // tls.connect is not an asynchronous function however it may still throw errors and requires to be wrapped with try/catch\n        try {\n            this._socket = tls.connect(opts, () => {\n                this.secure = true;\n                this.upgrading = false;\n                this._socket.on('data', this._onSocketData);\n\n                socketPlain.removeListener('close', this._onSocketClose);\n                socketPlain.removeListener('end', this._onSocketEnd);\n\n                return callback(null, true);\n            });\n        } catch (err) {\n            return callback(err);\n        }\n\n        this._socket.on('error', this._onSocketError);\n        this._socket.once('close', this._onSocketClose);\n        this._socket.once('end', this._onSocketEnd);\n\n        this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n        this._socket.on('timeout', this._onSocketTimeout);\n\n        // resume in case the socket was paused\n        socketPlain.resume();\n    }\n\n    /**\n     * Processes queued responses from the server\n     *\n     * @param {Boolean} force If true, ignores _processing flag\n     */\n    _processResponse() {\n        if (!this._responseQueue.length) {\n            return false;\n        }\n\n        let str = (this.lastServerResponse = (this._responseQueue.shift() || '').toString());\n\n        if (/^\\d+-/.test(str.split('\\n').pop())) {\n            // keep waiting for the final part of multiline response\n            return;\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'server'\n                },\n                str.replace(/\\r?\\n$/, '')\n            );\n        }\n\n        if (!str.trim()) {\n            // skip unexpected empty lines\n            setImmediate(() => this._processResponse());\n        }\n\n        let action = this._responseActions.shift();\n\n        if (typeof action === 'function') {\n            action.call(this, str);\n            setImmediate(() => this._processResponse());\n        } else {\n            return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n        }\n    }\n\n    /**\n     * Send a command to the server, append \\r\\n\n     *\n     * @param {String} str String to be sent to the server\n     * @param {String} logStr Optional string to be used for logging instead of the actual string\n     */\n    _sendCommand(str, logStr) {\n        if (this._destroyed) {\n            // Connection already closed, can't send any more data\n            return;\n        }\n\n        if (this._socket.destroyed) {\n            return this.close();\n        }\n\n        if (this.options.debug || this.options.transactionLog) {\n            this.logger.debug(\n                {\n                    tnx: 'client'\n                },\n                (logStr || str || '').toString().replace(/\\r?\\n$/, '')\n            );\n        }\n\n        this._socket.write(Buffer.from(str + '\\r\\n', 'utf-8'));\n    }\n\n    /**\n     * Initiates a new message by submitting envelope data, starting with\n     * MAIL FROM: command\n     *\n     * @param {Object} envelope Envelope object in the form of\n     *        {from:'...', to:['...']}\n     *        or\n     *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n     */\n    _setEnvelope(envelope, callback) {\n        let args = [];\n        let useSmtpUtf8 = false;\n\n        this._envelope = envelope || {};\n        this._envelope.from = ((this._envelope.from && this._envelope.from.address) || this._envelope.from || '').toString().trim();\n\n        this._envelope.to = [].concat(this._envelope.to || []).map(to => ((to && to.address) || to || '').toString().trim());\n\n        if (!this._envelope.to.length) {\n            return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n        }\n\n        if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n            return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the sender address uses only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            useSmtpUtf8 = true;\n        }\n\n        for (let i = 0, len = this._envelope.to.length; i < len; i++) {\n            if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n                return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n            }\n\n            // check if the recipients addresses use only ASCII characters,\n            // otherwise require usage of SMTPUTF8 extension\n            if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n                useSmtpUtf8 = true;\n            }\n        }\n\n        // clone the recipients array for latter manipulation\n        this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n        this._envelope.rejected = [];\n        this._envelope.rejectedErrors = [];\n        this._envelope.accepted = [];\n\n        if (this._envelope.dsn) {\n            try {\n                this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n            } catch (err) {\n                return callback(this._formatError('Invalid DSN ' + err.message, 'EENVELOPE', false, 'API'));\n            }\n        }\n\n        this._responseActions.push(str => {\n            this._actionMAIL(str, callback);\n        });\n\n        // If the server supports SMTPUTF8 and the envelope includes an internationalized\n        // email address then append SMTPUTF8 keyword to the MAIL FROM command\n        if (useSmtpUtf8 && this._supportedExtensions.includes('SMTPUTF8')) {\n            args.push('SMTPUTF8');\n            this._usingSmtpUtf8 = true;\n        }\n\n        // If the server supports 8BITMIME and the message might contain non-ascii bytes\n        // then append the 8BITMIME keyword to the MAIL FROM command\n        if (this._envelope.use8BitMime && this._supportedExtensions.includes('8BITMIME')) {\n            args.push('BODY=8BITMIME');\n            this._using8BitMime = true;\n        }\n\n        if (this._envelope.size && this._supportedExtensions.includes('SIZE')) {\n            args.push('SIZE=' + this._envelope.size);\n        }\n\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the MAIL FROM command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.ret) {\n                args.push('RET=' + shared.encodeXText(this._envelope.dsn.ret));\n            }\n            if (this._envelope.dsn.envid) {\n                args.push('ENVID=' + shared.encodeXText(this._envelope.dsn.envid));\n            }\n        }\n\n        this._sendCommand('MAIL FROM:<' + this._envelope.from + '>' + (args.length ? ' ' + args.join(' ') : ''));\n    }\n\n    _setDsnEnvelope(params) {\n        let ret = (params.ret || params.return || '').toString().toUpperCase() || null;\n        if (ret) {\n            switch (ret) {\n                case 'HDRS':\n                case 'HEADERS':\n                    ret = 'HDRS';\n                    break;\n                case 'FULL':\n                case 'BODY':\n                    ret = 'FULL';\n                    break;\n            }\n        }\n\n        if (ret && !['FULL', 'HDRS'].includes(ret)) {\n            throw new Error('ret: ' + JSON.stringify(ret));\n        }\n\n        let envid = (params.envid || params.id || '').toString() || null;\n\n        let notify = params.notify || null;\n        if (notify) {\n            if (typeof notify === 'string') {\n                notify = notify.split(',');\n            }\n            notify = notify.map(n => n.trim().toUpperCase());\n            let validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n            let invaliNotify = notify.filter(n => !validNotify.includes(n));\n            if (invaliNotify.length || (notify.length > 1 && notify.includes('NEVER'))) {\n                throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n            }\n            notify = notify.join(',');\n        }\n\n        let orcpt = (params.recipient || params.orcpt || '').toString() || null;\n        if (orcpt && orcpt.indexOf(';') < 0) {\n            orcpt = 'rfc822;' + orcpt;\n        }\n\n        return {\n            ret,\n            envid,\n            notify,\n            orcpt\n        };\n    }\n\n    _getDsnRcptToArgs() {\n        let args = [];\n        // If the server supports DSN and the envelope includes an DSN prop\n        // then append DSN params to the RCPT TO command\n        if (this._envelope.dsn && this._supportedExtensions.includes('DSN')) {\n            if (this._envelope.dsn.notify) {\n                args.push('NOTIFY=' + shared.encodeXText(this._envelope.dsn.notify));\n            }\n            if (this._envelope.dsn.orcpt) {\n                args.push('ORCPT=' + shared.encodeXText(this._envelope.dsn.orcpt));\n            }\n        }\n        return args.length ? ' ' + args.join(' ') : '';\n    }\n\n    _createSendStream(callback) {\n        let dataStream = new DataStream();\n        let logStream;\n\n        if (this.options.lmtp) {\n            this._envelope.accepted.forEach((recipient, i) => {\n                let final = i === this._envelope.accepted.length - 1;\n                this._responseActions.push(str => {\n                    this._actionLMTPStream(recipient, final, str, callback);\n                });\n            });\n        } else {\n            this._responseActions.push(str => {\n                this._actionSMTPStream(str, callback);\n            });\n        }\n\n        dataStream.pipe(this._socket, {\n            end: false\n        });\n\n        if (this.options.debug) {\n            logStream = new PassThrough();\n            logStream.on('readable', () => {\n                let chunk;\n                while ((chunk = logStream.read())) {\n                    this.logger.debug(\n                        {\n                            tnx: 'message'\n                        },\n                        chunk.toString('binary').replace(/\\r?\\n$/, '')\n                    );\n                }\n            });\n            dataStream.pipe(logStream);\n        }\n\n        dataStream.once('end', () => {\n            this.logger.info(\n                {\n                    tnx: 'message',\n                    inByteCount: dataStream.inByteCount,\n                    outByteCount: dataStream.outByteCount\n                },\n                '<%s bytes encoded mime message (source size %s bytes)>',\n                dataStream.outByteCount,\n                dataStream.inByteCount\n            );\n        });\n\n        return dataStream;\n    }\n\n    /** ACTIONS **/\n\n    /**\n     * Will be run after the connection is created and the server sends\n     * a greeting. If the incoming message starts with 220 initiate\n     * SMTP session by sending EHLO command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionGreeting(str) {\n        clearTimeout(this._greetingTimeout);\n\n        if (str.substr(0, 3) !== '220') {\n            this._onError(new Error('Invalid greeting. response=' + str), 'EPROTOCOL', str, 'CONN');\n            return;\n        }\n\n        if (this.options.lmtp) {\n            this._responseActions.push(this._actionLHLO);\n            this._sendCommand('LHLO ' + this.name);\n        } else {\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        }\n    }\n\n    /**\n     * Handles server response for LHLO command. If it yielded in\n     * error, emit 'error', otherwise treat this as an EHLO response\n     *\n     * @param {String} str Message from the server\n     */\n    _actionLHLO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid LHLO. response=' + str), 'EPROTOCOL', str, 'LHLO');\n            return;\n        }\n\n        this._actionEHLO(str);\n    }\n\n    /**\n     * Handles server response for EHLO command. If it yielded in\n     * error, try HELO instead, otherwise initiate TLS negotiation\n     * if STARTTLS is supported by the server or move into the\n     * authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionEHLO(str) {\n        let match;\n\n        if (str.substr(0, 3) === '421') {\n            this._onError(new Error('Server terminates connection. response=' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            if (this.options.requireTLS) {\n                this._onError(\n                    new Error('EHLO failed but HELO does not support required STARTTLS. response=' + str),\n                    'ECONNECTION',\n                    str,\n                    'EHLO'\n                );\n                return;\n            }\n\n            // Try HELO instead\n            this._responseActions.push(this._actionHELO);\n            this._sendCommand('HELO ' + this.name);\n            return;\n        }\n\n        this._ehloLines = str\n            .split(/\\r?\\n/)\n            .map(line => line.replace(/^\\d+[ -]/, '').trim())\n            .filter(line => line)\n            .slice(1);\n\n        // Detect if the server supports STARTTLS\n        if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\\b/im.test(str) || this.options.requireTLS)) {\n            this._sendCommand('STARTTLS');\n            this._responseActions.push(this._actionSTARTTLS);\n            return;\n        }\n\n        // Detect if the server supports SMTPUTF8\n        if (/[ -]SMTPUTF8\\b/im.test(str)) {\n            this._supportedExtensions.push('SMTPUTF8');\n        }\n\n        // Detect if the server supports DSN\n        if (/[ -]DSN\\b/im.test(str)) {\n            this._supportedExtensions.push('DSN');\n        }\n\n        // Detect if the server supports 8BITMIME\n        if (/[ -]8BITMIME\\b/im.test(str)) {\n            this._supportedExtensions.push('8BITMIME');\n        }\n\n        // Detect if the server supports PIPELINING\n        if (/[ -]PIPELINING\\b/im.test(str)) {\n            this._supportedExtensions.push('PIPELINING');\n        }\n\n        // Detect if the server supports AUTH\n        if (/[ -]AUTH\\b/i.test(str)) {\n            this.allowsAuth = true;\n        }\n\n        // Detect if the server supports PLAIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n            this._supportedAuth.push('PLAIN');\n        }\n\n        // Detect if the server supports LOGIN auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n            this._supportedAuth.push('LOGIN');\n        }\n\n        // Detect if the server supports CRAM-MD5 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n            this._supportedAuth.push('CRAM-MD5');\n        }\n\n        // Detect if the server supports XOAUTH2 auth\n        if (/[ -]AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n            this._supportedAuth.push('XOAUTH2');\n        }\n\n        // Detect if the server supports SIZE extensions (and the max allowed size)\n        if ((match = str.match(/[ -]SIZE(?:[ \\t]+(\\d+))?/im))) {\n            this._supportedExtensions.push('SIZE');\n            this._maxAllowedSize = Number(match[1]) || 0;\n        }\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for HELO command. If it yielded in\n     * error, emit 'error', otherwise move into the authentication phase.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionHELO(str) {\n        if (str.charAt(0) !== '2') {\n            this._onError(new Error('Invalid HELO. response=' + str), 'EPROTOCOL', str, 'HELO');\n            return;\n        }\n\n        // assume that authentication is enabled (most probably is not though)\n        this.allowsAuth = true;\n\n        this.emit('connect');\n    }\n\n    /**\n     * Handles server response for STARTTLS command. If there's an error\n     * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n     * succeedes restart the EHLO\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSTARTTLS(str) {\n        if (str.charAt(0) !== '2') {\n            if (this.options.opportunisticTLS) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp'\n                    },\n                    'Failed STARTTLS upgrade, continuing unencrypted'\n                );\n                return this.emit('connect');\n            }\n            this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n            return;\n        }\n\n        this._upgradeConnection((err, secured) => {\n            if (err) {\n                this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n                return;\n            }\n\n            this.logger.info(\n                {\n                    tnx: 'smtp'\n                },\n                'Connection upgraded with STARTTLS'\n            );\n\n            if (secured) {\n                // restart session\n                if (this.options.lmtp) {\n                    this._responseActions.push(this._actionLHLO);\n                    this._sendCommand('LHLO ' + this.name);\n                } else {\n                    this._responseActions.push(this._actionEHLO);\n                    this._sendCommand('EHLO ' + this.name);\n                }\n            } else {\n                this.emit('connect');\n            }\n        });\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n     * response needs to be base64 encoded username. We do not need\n     * exact match but settle with 334 response in general as some\n     * hosts invalidly use a longer message than VXNlcm5hbWU6\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_USER(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 VXNlcm5hbWU6'\n            callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n            return;\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTH_LOGIN_PASS(str, callback);\n        });\n\n        this._sendCommand(Buffer.from(this._auth.credentials.user + '', 'utf-8').toString('base64'));\n    }\n\n    /**\n     * Handle the response for AUTH CRAM-MD5 command. We are expecting\n     * '334 <challenge string>'. Data to be sent as response needs to be\n     * base64 decoded challenge string, MD5 hashed using the password as\n     * a HMAC key, prefixed by the username and a space, and finally all\n     * base64 encoded again.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5(str, callback) {\n        let challengeMatch = str.match(/^334\\s+(.+)$/);\n        let challengeString = '';\n\n        if (!challengeMatch) {\n            return callback(\n                this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5')\n            );\n        } else {\n            challengeString = challengeMatch[1];\n        }\n\n        // Decode from base64\n        let base64decoded = Buffer.from(challengeString, 'base64').toString('ascii'),\n            hmacMD5 = crypto.createHmac('md5', this._auth.credentials.pass);\n\n        hmacMD5.update(base64decoded);\n\n        let prepended = this._auth.credentials.user + ' ' + hmacMD5.digest('hex');\n\n        this._responseActions.push(str => {\n            this._actionAUTH_CRAM_MD5_PASS(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from(prepended).toString('base64'),\n            // hidden hash for logs\n            Buffer.from(this._auth.credentials.user + ' /* secret */').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response to CRAM-MD5 authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_CRAM_MD5_PASS(str, callback) {\n        if (!str.match(/^235\\s+/)) {\n            return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle the response for AUTH LOGIN command. We are expecting\n     * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n     * response needs to be base64 encoded password.\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTH_LOGIN_PASS(str, callback) {\n        if (!/^334[ -]/.test(str)) {\n            // expecting '334 UGFzc3dvcmQ6'\n            return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        }\n\n        this._responseActions.push(str => {\n            this._actionAUTHComplete(str, callback);\n        });\n\n        this._sendCommand(\n            Buffer.from((this._auth.credentials.pass || '').toString(), 'utf-8').toString('base64'),\n            // Hidden pass for logs\n            Buffer.from('/* secret */', 'utf-8').toString('base64')\n        );\n    }\n\n    /**\n     * Handles the response for authentication, if there's no error,\n     * the user can be considered logged in. Start waiting for a message to send\n     *\n     * @param {String} str Message from the server\n     */\n    _actionAUTHComplete(str, isRetry, callback) {\n        if (!callback && typeof isRetry === 'function') {\n            callback = isRetry;\n            isRetry = false;\n        }\n\n        if (str.substr(0, 3) === '334') {\n            this._responseActions.push(str => {\n                if (isRetry || this._authMethod !== 'XOAUTH2') {\n                    this._actionAUTHComplete(str, true, callback);\n                } else {\n                    // fetch a new OAuth2 access token\n                    setImmediate(() => this._handleXOauth2Token(true, callback));\n                }\n            });\n            this._sendCommand('');\n            return;\n        }\n\n        if (str.charAt(0) !== '2') {\n            this.logger.info(\n                {\n                    tnx: 'smtp',\n                    username: this._auth.user,\n                    action: 'authfail',\n                    method: this._authMethod\n                },\n                'User %s failed to authenticate',\n                JSON.stringify(this._auth.user)\n            );\n            return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n        }\n\n        this.logger.info(\n            {\n                tnx: 'smtp',\n                username: this._auth.user,\n                action: 'authenticated',\n                method: this._authMethod\n            },\n            'User %s authenticated',\n            JSON.stringify(this._auth.user)\n        );\n        this.authenticated = true;\n        callback(null, true);\n    }\n\n    /**\n     * Handle response for a MAIL FROM: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionMAIL(str, callback) {\n        let message, curRecipient;\n        if (Number(str.charAt(0)) !== 2) {\n            if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Mail command failed';\n            }\n            return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n        }\n\n        if (!this._envelope.rcptQueue.length) {\n            return callback(this._formatError(\"Can't send mail - no recipients defined\", 'EENVELOPE', false, 'API'));\n        } else {\n            this._recipientQueue = [];\n\n            if (this._supportedExtensions.includes('PIPELINING')) {\n                while (this._envelope.rcptQueue.length) {\n                    curRecipient = this._envelope.rcptQueue.shift();\n                    this._recipientQueue.push(curRecipient);\n                    this._responseActions.push(str => {\n                        this._actionRCPT(str, callback);\n                    });\n                    this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n                }\n            } else {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(str => {\n                    this._actionRCPT(str, callback);\n                });\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        }\n    }\n\n    /**\n     * Handle response for a RCPT TO: command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionRCPT(str, callback) {\n        let message,\n            err,\n            curRecipient = this._recipientQueue.shift();\n        if (Number(str.charAt(0)) !== 2) {\n            // this is a soft error\n            if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n                message = 'Internationalized mailbox name not allowed';\n            } else {\n                message = 'Recipient command failed';\n            }\n            this._envelope.rejected.push(curRecipient);\n            // store error for the failed recipient\n            err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n            err.recipient = curRecipient;\n            this._envelope.rejectedErrors.push(err);\n        } else {\n            this._envelope.accepted.push(curRecipient);\n        }\n\n        if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n            if (this._envelope.rejected.length < this._envelope.to.length) {\n                this._responseActions.push(str => {\n                    this._actionDATA(str, callback);\n                });\n                this._sendCommand('DATA');\n            } else {\n                err = this._formatError(\"Can't send mail - all recipients were rejected\", 'EENVELOPE', str, 'RCPT TO');\n                err.rejected = this._envelope.rejected;\n                err.rejectedErrors = this._envelope.rejectedErrors;\n                return callback(err);\n            }\n        } else if (this._envelope.rcptQueue.length) {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(str => {\n                this._actionRCPT(str, callback);\n            });\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n\n    /**\n     * Handle response for a DATA command\n     *\n     * @param {String} str Message from the server\n     */\n    _actionDATA(str, callback) {\n        // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n        // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n        if (!/^[23]/.test(str)) {\n            return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n        }\n\n        let response = {\n            accepted: this._envelope.accepted,\n            rejected: this._envelope.rejected\n        };\n\n        if (this._ehloLines && this._ehloLines.length) {\n            response.ehlo = this._ehloLines;\n        }\n\n        if (this._envelope.rejectedErrors.length) {\n            response.rejectedErrors = this._envelope.rejectedErrors;\n        }\n\n        callback(null, response);\n    }\n\n    /**\n     * Handle response for a DATA stream when using SMTP\n     * We expect a single response that defines if the sending succeeded or failed\n     *\n     * @param {String} str Message from the server\n     */\n    _actionSMTPStream(str, callback) {\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n        } else {\n            // Message sent succesfully\n            return callback(null, str);\n        }\n    }\n\n    /**\n     * Handle response for a DATA stream\n     * We expect a separate response for every recipient. All recipients can either\n     * succeed or fail separately\n     *\n     * @param {String} recipient The recipient this response applies to\n     * @param {Boolean} final Is this the final recipient?\n     * @param {String} str Message from the server\n     */\n    _actionLMTPStream(recipient, final, str, callback) {\n        let err;\n        if (Number(str.charAt(0)) !== 2) {\n            // Message failed\n            err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n            err.recipient = recipient;\n            this._envelope.rejected.push(recipient);\n            this._envelope.rejectedErrors.push(err);\n            for (let i = 0, len = this._envelope.accepted.length; i < len; i++) {\n                if (this._envelope.accepted[i] === recipient) {\n                    this._envelope.accepted.splice(i, 1);\n                }\n            }\n        }\n        if (final) {\n            return callback(null, str);\n        }\n    }\n\n    _handleXOauth2Token(isRetry, callback) {\n        this._auth.oauth2.getToken(isRetry, (err, accessToken) => {\n            if (err) {\n                this.logger.info(\n                    {\n                        tnx: 'smtp',\n                        username: this._auth.user,\n                        action: 'authfail',\n                        method: this._authMethod\n                    },\n                    'User %s failed to authenticate',\n                    JSON.stringify(this._auth.user)\n                );\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._responseActions.push(str => {\n                this._actionAUTHComplete(str, isRetry, callback);\n            });\n            this._sendCommand(\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token(accessToken),\n                //  Hidden for logs\n                'AUTH XOAUTH2 ' + this._auth.oauth2.buildXOAuth2Token('/* secret */')\n            );\n        });\n    }\n\n    /**\n     *\n     * @param {string} command\n     * @private\n     */\n    _isDestroyedMessage(command) {\n        if (this._destroyed) {\n            return 'Cannot ' + command + ' - smtp connection is already destroyed.';\n        }\n\n        if (this._socket) {\n            if (this._socket.destroyed) {\n                return 'Cannot ' + command + ' - smtp connection socket is already destroyed.';\n            }\n\n            if (!this._socket.writable) {\n                return 'Cannot ' + command + ' - smtp connection socket is already half-closed.';\n            }\n        }\n    }\n\n    _getHostname() {\n        // defaul hostname is machine hostname or [IP]\n        let defaultHostname;\n        try {\n            defaultHostname = os.hostname() || '';\n        } catch (_err) {\n            // fails on windows 7\n            defaultHostname = 'localhost';\n        }\n\n        // ignore if not FQDN\n        if (!defaultHostname || defaultHostname.indexOf('.') < 0) {\n            defaultHostname = '[127.0.0.1]';\n        }\n\n        // IP should be enclosed in []\n        if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n            defaultHostname = '[' + defaultHostname + ']';\n        }\n\n        return defaultHostname;\n    }\n}\n\nmodule.exports = SMTPConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}