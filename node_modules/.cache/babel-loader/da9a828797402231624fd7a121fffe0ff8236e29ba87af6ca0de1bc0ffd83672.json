{"ast":null,"code":"/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst nmfetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\nconst os = require('os');\nconst DNS_TTL = 5 * 60 * 1000;\nconst CACHE_CLEANUP_INTERVAL = 30 * 1000; // Minimum 30 seconds between cleanups\nconst MAX_CACHE_SIZE = 1000; // Maximum number of entries in cache\n\nlet lastCacheCleanup = 0;\nmodule.exports._lastCacheCleanup = () => lastCacheCleanup;\nmodule.exports._resetCacheCleanup = () => {\n  lastCacheCleanup = 0;\n};\nlet networkInterfaces;\ntry {\n  networkInterfaces = os.networkInterfaces();\n} catch (_err) {\n  // fails on some systems\n}\nmodule.exports.networkInterfaces = networkInterfaces;\nconst isFamilySupported = (family, allowInternal) => {\n  let networkInterfaces = module.exports.networkInterfaces;\n  if (!networkInterfaces) {\n    // hope for the best\n    return true;\n  }\n  const familySupported =\n  // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n  Object.keys(networkInterfaces).map(key => networkInterfaces[key])\n  // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n  .reduce((acc, val) => acc.concat(val), []).filter(i => !i.internal || allowInternal).filter(i => i.family === 'IPv' + family || i.family === family).length > 0;\n  return familySupported;\n};\nconst resolver = (family, hostname, options, callback) => {\n  options = options || {};\n  const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n  if (!familySupported) {\n    return callback(null, []);\n  }\n  const resolver = dns.Resolver ? new dns.Resolver(options) : dns;\n  resolver['resolve' + family](hostname, (err, addresses) => {\n    if (err) {\n      switch (err.code) {\n        case dns.NODATA:\n        case dns.NOTFOUND:\n        case dns.NOTIMP:\n        case dns.SERVFAIL:\n        case dns.CONNREFUSED:\n        case dns.REFUSED:\n        case 'EAI_AGAIN':\n          return callback(null, []);\n      }\n      return callback(err);\n    }\n    return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n  });\n};\nconst dnsCache = module.exports.dnsCache = new Map();\nconst formatDNSValue = (value, extra) => {\n  if (!value) {\n    return Object.assign({}, extra || {});\n  }\n  return Object.assign({\n    servername: value.servername,\n    host: !value.addresses || !value.addresses.length ? null : value.addresses.length === 1 ? value.addresses[0] : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n  }, extra || {});\n};\nmodule.exports.resolveHostname = (options, callback) => {\n  options = options || {};\n  if (!options.host && options.servername) {\n    options.host = options.servername;\n  }\n  if (!options.host || net.isIP(options.host)) {\n    // nothing to do here\n    let value = {\n      addresses: [options.host],\n      servername: options.servername || false\n    };\n    return callback(null, formatDNSValue(value, {\n      cached: false\n    }));\n  }\n  let cached;\n  if (dnsCache.has(options.host)) {\n    cached = dnsCache.get(options.host);\n\n    // Lazy cleanup with time throttling\n    const now = Date.now();\n    if (now - lastCacheCleanup > CACHE_CLEANUP_INTERVAL) {\n      lastCacheCleanup = now;\n\n      // Clean up expired entries\n      for (const [host, entry] of dnsCache.entries()) {\n        if (entry.expires && entry.expires < now) {\n          dnsCache.delete(host);\n        }\n      }\n\n      // If cache is still too large, remove oldest entries\n      if (dnsCache.size > MAX_CACHE_SIZE) {\n        const toDelete = Math.floor(MAX_CACHE_SIZE * 0.1); // Remove 10% of entries\n        const keys = Array.from(dnsCache.keys()).slice(0, toDelete);\n        keys.forEach(key => dnsCache.delete(key));\n      }\n    }\n    if (!cached.expires || cached.expires >= now) {\n      return callback(null, formatDNSValue(cached.value, {\n        cached: true\n      }));\n    }\n  }\n  resolver(4, options.host, options, (err, addresses) => {\n    if (err) {\n      if (cached) {\n        dnsCache.set(options.host, {\n          value: cached.value,\n          expires: Date.now() + (options.dnsTtl || DNS_TTL)\n        });\n        return callback(null, formatDNSValue(cached.value, {\n          cached: true,\n          error: err\n        }));\n      }\n      return callback(err);\n    }\n    if (addresses && addresses.length) {\n      let value = {\n        addresses,\n        servername: options.servername || options.host\n      };\n      dnsCache.set(options.host, {\n        value,\n        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n      });\n      return callback(null, formatDNSValue(value, {\n        cached: false\n      }));\n    }\n    resolver(6, options.host, options, (err, addresses) => {\n      if (err) {\n        if (cached) {\n          dnsCache.set(options.host, {\n            value: cached.value,\n            expires: Date.now() + (options.dnsTtl || DNS_TTL)\n          });\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n        return callback(err);\n      }\n      if (addresses && addresses.length) {\n        let value = {\n          addresses,\n          servername: options.servername || options.host\n        };\n        dnsCache.set(options.host, {\n          value,\n          expires: Date.now() + (options.dnsTtl || DNS_TTL)\n        });\n        return callback(null, formatDNSValue(value, {\n          cached: false\n        }));\n      }\n      try {\n        dns.lookup(options.host, {\n          all: true\n        }, (err, addresses) => {\n          if (err) {\n            if (cached) {\n              dnsCache.set(options.host, {\n                value: cached.value,\n                expires: Date.now() + (options.dnsTtl || DNS_TTL)\n              });\n              return callback(null, formatDNSValue(cached.value, {\n                cached: true,\n                error: err\n              }));\n            }\n            return callback(err);\n          }\n          let address = addresses ? addresses.filter(addr => isFamilySupported(addr.family)).map(addr => addr.address).shift() : false;\n          if (addresses && addresses.length && !address) {\n            // there are addresses but none can be used\n            console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);\n          }\n          if (!address && cached) {\n            // nothing was found, fallback to cached value\n            return callback(null, formatDNSValue(cached.value, {\n              cached: true\n            }));\n          }\n          let value = {\n            addresses: address ? [address] : [options.host],\n            servername: options.servername || options.host\n          };\n          dnsCache.set(options.host, {\n            value,\n            expires: Date.now() + (options.dnsTtl || DNS_TTL)\n          });\n          return callback(null, formatDNSValue(value, {\n            cached: false\n          }));\n        });\n      } catch (_err) {\n        if (cached) {\n          dnsCache.set(options.host, {\n            value: cached.value,\n            expires: Date.now() + (options.dnsTtl || DNS_TTL)\n          });\n          return callback(null, formatDNSValue(cached.value, {\n            cached: true,\n            error: err\n          }));\n        }\n        return callback(err);\n      }\n    });\n  });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n  str = str || '';\n  let options = {};\n  [urllib.parse(str, true)].forEach(url => {\n    let auth;\n    switch (url.protocol) {\n      case 'smtp:':\n        options.secure = false;\n        break;\n      case 'smtps:':\n        options.secure = true;\n        break;\n      case 'direct:':\n        options.direct = true;\n        break;\n    }\n    if (!isNaN(url.port) && Number(url.port)) {\n      options.port = Number(url.port);\n    }\n    if (url.hostname) {\n      options.host = url.hostname;\n    }\n    if (url.auth) {\n      auth = url.auth.split(':');\n      if (!options.auth) {\n        options.auth = {};\n      }\n      options.auth.user = auth.shift();\n      options.auth.pass = auth.join(':');\n    }\n    Object.keys(url.query || {}).forEach(key => {\n      let obj = options;\n      let lKey = key;\n      let value = url.query[key];\n      if (!isNaN(value)) {\n        value = Number(value);\n      }\n      switch (value) {\n        case 'true':\n          value = true;\n          break;\n        case 'false':\n          value = false;\n          break;\n      }\n\n      // tls is nested object\n      if (key.indexOf('tls.') === 0) {\n        lKey = key.substr(4);\n        if (!options.tls) {\n          options.tls = {};\n        }\n        obj = options.tls;\n      } else if (key.indexOf('.') >= 0) {\n        // ignore nested properties besides tls\n        return;\n      }\n      if (!(lKey in obj)) {\n        obj[lKey] = value;\n      }\n    });\n  });\n  return options;\n};\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n  let entry = {};\n  Object.keys(defaults || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = defaults[key];\n    }\n  });\n  Object.keys(data || {}).forEach(key => {\n    if (key !== 'level') {\n      entry[key] = data[key];\n    }\n  });\n  logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n  options = options || {};\n  let response = {};\n  let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n  if (!options.logger) {\n    // use vanity logger\n    levels.forEach(level => {\n      response[level] = () => false;\n    });\n    return response;\n  }\n  let logger = options.logger;\n  if (options.logger === true) {\n    // create console logger\n    logger = createDefaultLogger(levels);\n  }\n  levels.forEach(level => {\n    response[level] = (data, message, ...args) => {\n      module.exports._logFunc(logger, level, defaults, data, message, ...args);\n    };\n  });\n  return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) => function () {\n  let args = Array.from(arguments);\n  let err = args.shift();\n  if (err) {\n    reject(err);\n  } else {\n    resolve(...args);\n  }\n};\nmodule.exports.parseDataURI = uri => {\n  if (typeof uri !== 'string') {\n    return null;\n  }\n\n  // Early return for non-data URIs to avoid unnecessary processing\n  if (!uri.startsWith('data:')) {\n    return null;\n  }\n\n  // Find the first comma safely - this prevents ReDoS\n  const commaPos = uri.indexOf(',');\n  if (commaPos === -1) {\n    return null;\n  }\n  const data = uri.substring(commaPos + 1);\n  const metaStr = uri.substring('data:'.length, commaPos);\n  let encoding;\n  const metaEntries = metaStr.split(';');\n  if (metaEntries.length > 0) {\n    const lastEntry = metaEntries[metaEntries.length - 1].toLowerCase().trim();\n    // Only recognize valid encoding types to prevent manipulation\n    if (['base64', 'utf8', 'utf-8'].includes(lastEntry) && lastEntry.indexOf('=') === -1) {\n      encoding = lastEntry;\n      metaEntries.pop();\n    }\n  }\n  const contentType = metaEntries.length > 0 ? metaEntries.shift() : 'application/octet-stream';\n  const params = {};\n  for (let i = 0; i < metaEntries.length; i++) {\n    const entry = metaEntries[i];\n    const sepPos = entry.indexOf('=');\n    if (sepPos > 0) {\n      // Ensure there's a key before the '='\n      const key = entry.substring(0, sepPos).trim();\n      const value = entry.substring(sepPos + 1).trim();\n      if (key) {\n        params[key] = value;\n      }\n    }\n  }\n\n  // Decode data based on encoding with proper error handling\n  let bufferData;\n  try {\n    if (encoding === 'base64') {\n      bufferData = Buffer.from(data, 'base64');\n    } else {\n      try {\n        bufferData = Buffer.from(decodeURIComponent(data));\n      } catch (_decodeError) {\n        bufferData = Buffer.from(data);\n      }\n    }\n  } catch (_bufferError) {\n    bufferData = Buffer.alloc(0);\n  }\n  return {\n    data: bufferData,\n    encoding: encoding || null,\n    contentType: contentType || 'application/octet-stream',\n    params\n  };\n};\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n  let promise;\n  if (!callback) {\n    promise = new Promise((resolve, reject) => {\n      callback = module.exports.callbackPromise(resolve, reject);\n    });\n  }\n  let content = data && data[key] && data[key].content || data[key];\n  let contentStream;\n  let encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8').toString().toLowerCase().replace(/[-_\\s]/g, '');\n  if (!content) {\n    return callback(null, content);\n  }\n  if (typeof content === 'object') {\n    if (typeof content.pipe === 'function') {\n      return resolveStream(content, (err, value) => {\n        if (err) {\n          return callback(err);\n        }\n        // we can't stream twice the same content, so we need\n        // to replace the stream object with the streaming result\n        if (data[key].content) {\n          data[key].content = value;\n        } else {\n          data[key] = value;\n        }\n        callback(null, value);\n      });\n    } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n      contentStream = nmfetch(content.path || content.href);\n      return resolveStream(contentStream, callback);\n    } else if (/^data:/i.test(content.path || content.href)) {\n      let parsedDataUri = module.exports.parseDataURI(content.path || content.href);\n      if (!parsedDataUri || !parsedDataUri.data) {\n        return callback(null, Buffer.from(0));\n      }\n      return callback(null, parsedDataUri.data);\n    } else if (content.path) {\n      return resolveStream(fs.createReadStream(content.path), callback);\n    }\n  }\n  if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n    content = Buffer.from(data[key].content, encoding);\n  }\n\n  // default action, return as is\n  setImmediate(() => callback(null, content));\n  return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function /* target, ... sources */\n() {\n  let args = Array.from(arguments);\n  let target = args.shift() || {};\n  args.forEach(source => {\n    Object.keys(source || {}).forEach(key => {\n      if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n        // tls and auth are special keys that need to be enumerated separately\n        // other objects are passed as is\n        if (!target[key]) {\n          // ensure that target has this key\n          target[key] = {};\n        }\n        Object.keys(source[key]).forEach(subKey => {\n          target[key][subKey] = source[key][subKey];\n        });\n      } else {\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n};\nmodule.exports.encodeXText = str => {\n  // ! 0x21\n  // + 0x2B\n  // = 0x3D\n  // ~ 0x7E\n  if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n    return str;\n  }\n  let buf = Buffer.from(str);\n  let result = '';\n  for (let i = 0, len = buf.length; i < len; i++) {\n    let c = buf[i];\n    if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n      result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n    } else {\n      result += String.fromCharCode(c);\n    }\n  }\n  return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n  let responded = false;\n  let chunks = [];\n  let chunklen = 0;\n  stream.on('error', err => {\n    if (responded) {\n      return;\n    }\n    responded = true;\n    callback(err);\n  });\n  stream.on('readable', () => {\n    let chunk;\n    while ((chunk = stream.read()) !== null) {\n      chunks.push(chunk);\n      chunklen += chunk.length;\n    }\n  });\n  stream.on('end', () => {\n    if (responded) {\n      return;\n    }\n    responded = true;\n    let value;\n    try {\n      value = Buffer.concat(chunks, chunklen);\n    } catch (E) {\n      return callback(E);\n    }\n    callback(null, value);\n  });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n  let levelMaxLen = 0;\n  let levelNames = new Map();\n  levels.forEach(level => {\n    if (level.length > levelMaxLen) {\n      levelMaxLen = level.length;\n    }\n  });\n  levels.forEach(level => {\n    let levelName = level.toUpperCase();\n    if (levelName.length < levelMaxLen) {\n      levelName += ' '.repeat(levelMaxLen - levelName.length);\n    }\n    levelNames.set(level, levelName);\n  });\n  let print = (level, entry, message, ...args) => {\n    let prefix = '';\n    if (entry) {\n      if (entry.tnx === 'server') {\n        prefix = 'S: ';\n      } else if (entry.tnx === 'client') {\n        prefix = 'C: ';\n      }\n      if (entry.sid) {\n        prefix = '[' + entry.sid + '] ' + prefix;\n      }\n      if (entry.cid) {\n        prefix = '[#' + entry.cid + '] ' + prefix;\n      }\n    }\n    message = util.format(message, ...args);\n    message.split(/\\r?\\n/).forEach(line => {\n      console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n    });\n  };\n  let logger = {};\n  levels.forEach(level => {\n    logger[level] = print.bind(null, level);\n  });\n  return logger;\n}","map":{"version":3,"names":["urllib","require","util","fs","nmfetch","dns","net","os","DNS_TTL","CACHE_CLEANUP_INTERVAL","MAX_CACHE_SIZE","lastCacheCleanup","module","exports","_lastCacheCleanup","_resetCacheCleanup","networkInterfaces","_err","isFamilySupported","family","allowInternal","familySupported","Object","keys","map","key","reduce","acc","val","concat","filter","i","internal","length","resolver","hostname","options","callback","allowInternalNetworkInterfaces","Resolver","err","addresses","code","NODATA","NOTFOUND","NOTIMP","SERVFAIL","CONNREFUSED","REFUSED","Array","isArray","dnsCache","Map","formatDNSValue","value","extra","assign","servername","host","Math","floor","random","resolveHostname","isIP","cached","has","get","now","Date","entry","entries","expires","delete","size","toDelete","from","slice","forEach","set","dnsTtl","error","lookup","all","address","addr","shift","console","warn","parseConnectionUrl","str","parse","url","auth","protocol","secure","direct","isNaN","port","Number","split","user","pass","join","query","obj","lKey","indexOf","substr","tls","_logFunc","logger","level","defaults","data","message","args","getLogger","response","levels","createDefaultLogger","callbackPromise","resolve","reject","arguments","parseDataURI","uri","startsWith","commaPos","substring","metaStr","encoding","metaEntries","lastEntry","toLowerCase","trim","includes","pop","contentType","params","sepPos","bufferData","Buffer","decodeURIComponent","_decodeError","_bufferError","alloc","resolveContent","promise","Promise","content","contentStream","toString","replace","pipe","resolveStream","test","path","href","parsedDataUri","createReadStream","setImmediate","target","source","subKey","encodeXText","buf","result","len","c","toUpperCase","String","fromCharCode","stream","responded","chunks","chunklen","on","chunk","read","push","E","levelMaxLen","levelNames","levelName","repeat","print","prefix","tnx","sid","cid","format","line","log","toISOString","bind"],"sources":["D:/bank/banking-finance-system/node_modules/nodemailer/lib/shared/index.js"],"sourcesContent":["/* eslint no-console: 0 */\n\n'use strict';\n\nconst urllib = require('url');\nconst util = require('util');\nconst fs = require('fs');\nconst nmfetch = require('../fetch');\nconst dns = require('dns');\nconst net = require('net');\nconst os = require('os');\n\nconst DNS_TTL = 5 * 60 * 1000;\nconst CACHE_CLEANUP_INTERVAL = 30 * 1000; // Minimum 30 seconds between cleanups\nconst MAX_CACHE_SIZE = 1000; // Maximum number of entries in cache\n\nlet lastCacheCleanup = 0;\nmodule.exports._lastCacheCleanup = () => lastCacheCleanup;\nmodule.exports._resetCacheCleanup = () => {\n    lastCacheCleanup = 0;\n};\n\nlet networkInterfaces;\ntry {\n    networkInterfaces = os.networkInterfaces();\n} catch (_err) {\n    // fails on some systems\n}\n\nmodule.exports.networkInterfaces = networkInterfaces;\n\nconst isFamilySupported = (family, allowInternal) => {\n    let networkInterfaces = module.exports.networkInterfaces;\n    if (!networkInterfaces) {\n        // hope for the best\n        return true;\n    }\n\n    const familySupported =\n        // crux that replaces Object.values(networkInterfaces) as Object.values is not supported in nodejs v6\n        Object.keys(networkInterfaces)\n            .map(key => networkInterfaces[key])\n            // crux that replaces .flat() as it is not supported in older Node versions (v10 and older)\n            .reduce((acc, val) => acc.concat(val), [])\n            .filter(i => !i.internal || allowInternal)\n            .filter(i => i.family === 'IPv' + family || i.family === family).length > 0;\n\n    return familySupported;\n};\n\nconst resolver = (family, hostname, options, callback) => {\n    options = options || {};\n    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);\n\n    if (!familySupported) {\n        return callback(null, []);\n    }\n\n    const resolver = dns.Resolver ? new dns.Resolver(options) : dns;\n    resolver['resolve' + family](hostname, (err, addresses) => {\n        if (err) {\n            switch (err.code) {\n                case dns.NODATA:\n                case dns.NOTFOUND:\n                case dns.NOTIMP:\n                case dns.SERVFAIL:\n                case dns.CONNREFUSED:\n                case dns.REFUSED:\n                case 'EAI_AGAIN':\n                    return callback(null, []);\n            }\n            return callback(err);\n        }\n        return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));\n    });\n};\n\nconst dnsCache = (module.exports.dnsCache = new Map());\n\nconst formatDNSValue = (value, extra) => {\n    if (!value) {\n        return Object.assign({}, extra || {});\n    }\n\n    return Object.assign(\n        {\n            servername: value.servername,\n            host:\n                !value.addresses || !value.addresses.length\n                    ? null\n                    : value.addresses.length === 1\n                      ? value.addresses[0]\n                      : value.addresses[Math.floor(Math.random() * value.addresses.length)]\n        },\n        extra || {}\n    );\n};\n\nmodule.exports.resolveHostname = (options, callback) => {\n    options = options || {};\n\n    if (!options.host && options.servername) {\n        options.host = options.servername;\n    }\n\n    if (!options.host || net.isIP(options.host)) {\n        // nothing to do here\n        let value = {\n            addresses: [options.host],\n            servername: options.servername || false\n        };\n        return callback(\n            null,\n            formatDNSValue(value, {\n                cached: false\n            })\n        );\n    }\n\n    let cached;\n    if (dnsCache.has(options.host)) {\n        cached = dnsCache.get(options.host);\n\n        // Lazy cleanup with time throttling\n        const now = Date.now();\n        if (now - lastCacheCleanup > CACHE_CLEANUP_INTERVAL) {\n            lastCacheCleanup = now;\n\n            // Clean up expired entries\n            for (const [host, entry] of dnsCache.entries()) {\n                if (entry.expires && entry.expires < now) {\n                    dnsCache.delete(host);\n                }\n            }\n\n            // If cache is still too large, remove oldest entries\n            if (dnsCache.size > MAX_CACHE_SIZE) {\n                const toDelete = Math.floor(MAX_CACHE_SIZE * 0.1); // Remove 10% of entries\n                const keys = Array.from(dnsCache.keys()).slice(0, toDelete);\n                keys.forEach(key => dnsCache.delete(key));\n            }\n        }\n\n        if (!cached.expires || cached.expires >= now) {\n            return callback(\n                null,\n                formatDNSValue(cached.value, {\n                    cached: true\n                })\n            );\n        }\n    }\n\n    resolver(4, options.host, options, (err, addresses) => {\n        if (err) {\n            if (cached) {\n                dnsCache.set(options.host, {\n                    value: cached.value,\n                    expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                });\n\n                return callback(\n                    null,\n                    formatDNSValue(cached.value, {\n                        cached: true,\n                        error: err\n                    })\n                );\n            }\n            return callback(err);\n        }\n\n        if (addresses && addresses.length) {\n            let value = {\n                addresses,\n                servername: options.servername || options.host\n            };\n\n            dnsCache.set(options.host, {\n                value,\n                expires: Date.now() + (options.dnsTtl || DNS_TTL)\n            });\n\n            return callback(\n                null,\n                formatDNSValue(value, {\n                    cached: false\n                })\n            );\n        }\n\n        resolver(6, options.host, options, (err, addresses) => {\n            if (err) {\n                if (cached) {\n                    dnsCache.set(options.host, {\n                        value: cached.value,\n                        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                    });\n\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n\n            if (addresses && addresses.length) {\n                let value = {\n                    addresses,\n                    servername: options.servername || options.host\n                };\n\n                dnsCache.set(options.host, {\n                    value,\n                    expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                });\n\n                return callback(\n                    null,\n                    formatDNSValue(value, {\n                        cached: false\n                    })\n                );\n            }\n\n            try {\n                dns.lookup(options.host, { all: true }, (err, addresses) => {\n                    if (err) {\n                        if (cached) {\n                            dnsCache.set(options.host, {\n                                value: cached.value,\n                                expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                            });\n\n                            return callback(\n                                null,\n                                formatDNSValue(cached.value, {\n                                    cached: true,\n                                    error: err\n                                })\n                            );\n                        }\n                        return callback(err);\n                    }\n\n                    let address = addresses\n                        ? addresses\n                              .filter(addr => isFamilySupported(addr.family))\n                              .map(addr => addr.address)\n                              .shift()\n                        : false;\n\n                    if (addresses && addresses.length && !address) {\n                        // there are addresses but none can be used\n                        console.warn(`Failed to resolve IPv${addresses[0].family} addresses with current network`);\n                    }\n\n                    if (!address && cached) {\n                        // nothing was found, fallback to cached value\n                        return callback(\n                            null,\n                            formatDNSValue(cached.value, {\n                                cached: true\n                            })\n                        );\n                    }\n\n                    let value = {\n                        addresses: address ? [address] : [options.host],\n                        servername: options.servername || options.host\n                    };\n\n                    dnsCache.set(options.host, {\n                        value,\n                        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                    });\n\n                    return callback(\n                        null,\n                        formatDNSValue(value, {\n                            cached: false\n                        })\n                    );\n                });\n            } catch (_err) {\n                if (cached) {\n                    dnsCache.set(options.host, {\n                        value: cached.value,\n                        expires: Date.now() + (options.dnsTtl || DNS_TTL)\n                    });\n\n                    return callback(\n                        null,\n                        formatDNSValue(cached.value, {\n                            cached: true,\n                            error: err\n                        })\n                    );\n                }\n                return callback(err);\n            }\n        });\n    });\n};\n/**\n * Parses connection url to a structured configuration object\n *\n * @param {String} str Connection url\n * @return {Object} Configuration object\n */\nmodule.exports.parseConnectionUrl = str => {\n    str = str || '';\n    let options = {};\n\n    [urllib.parse(str, true)].forEach(url => {\n        let auth;\n\n        switch (url.protocol) {\n            case 'smtp:':\n                options.secure = false;\n                break;\n            case 'smtps:':\n                options.secure = true;\n                break;\n            case 'direct:':\n                options.direct = true;\n                break;\n        }\n\n        if (!isNaN(url.port) && Number(url.port)) {\n            options.port = Number(url.port);\n        }\n\n        if (url.hostname) {\n            options.host = url.hostname;\n        }\n\n        if (url.auth) {\n            auth = url.auth.split(':');\n\n            if (!options.auth) {\n                options.auth = {};\n            }\n\n            options.auth.user = auth.shift();\n            options.auth.pass = auth.join(':');\n        }\n\n        Object.keys(url.query || {}).forEach(key => {\n            let obj = options;\n            let lKey = key;\n            let value = url.query[key];\n\n            if (!isNaN(value)) {\n                value = Number(value);\n            }\n\n            switch (value) {\n                case 'true':\n                    value = true;\n                    break;\n                case 'false':\n                    value = false;\n                    break;\n            }\n\n            // tls is nested object\n            if (key.indexOf('tls.') === 0) {\n                lKey = key.substr(4);\n                if (!options.tls) {\n                    options.tls = {};\n                }\n                obj = options.tls;\n            } else if (key.indexOf('.') >= 0) {\n                // ignore nested properties besides tls\n                return;\n            }\n\n            if (!(lKey in obj)) {\n                obj[lKey] = value;\n            }\n        });\n    });\n\n    return options;\n};\n\nmodule.exports._logFunc = (logger, level, defaults, data, message, ...args) => {\n    let entry = {};\n\n    Object.keys(defaults || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = defaults[key];\n        }\n    });\n\n    Object.keys(data || {}).forEach(key => {\n        if (key !== 'level') {\n            entry[key] = data[key];\n        }\n    });\n\n    logger[level](entry, message, ...args);\n};\n\n/**\n * Returns a bunyan-compatible logger interface. Uses either provided logger or\n * creates a default console logger\n *\n * @param {Object} [options] Options object that might include 'logger' value\n * @return {Object} bunyan compatible logger\n */\nmodule.exports.getLogger = (options, defaults) => {\n    options = options || {};\n\n    let response = {};\n    let levels = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'];\n\n    if (!options.logger) {\n        // use vanity logger\n        levels.forEach(level => {\n            response[level] = () => false;\n        });\n        return response;\n    }\n\n    let logger = options.logger;\n\n    if (options.logger === true) {\n        // create console logger\n        logger = createDefaultLogger(levels);\n    }\n\n    levels.forEach(level => {\n        response[level] = (data, message, ...args) => {\n            module.exports._logFunc(logger, level, defaults, data, message, ...args);\n        };\n    });\n\n    return response;\n};\n\n/**\n * Wrapper for creating a callback that either resolves or rejects a promise\n * based on input\n *\n * @param {Function} resolve Function to run if callback is called\n * @param {Function} reject Function to run if callback ends with an error\n */\nmodule.exports.callbackPromise = (resolve, reject) =>\n    function () {\n        let args = Array.from(arguments);\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n\nmodule.exports.parseDataURI = uri => {\n    if (typeof uri !== 'string') {\n        return null;\n    }\n\n    // Early return for non-data URIs to avoid unnecessary processing\n    if (!uri.startsWith('data:')) {\n        return null;\n    }\n\n    // Find the first comma safely - this prevents ReDoS\n    const commaPos = uri.indexOf(',');\n    if (commaPos === -1) {\n        return null;\n    }\n\n    const data = uri.substring(commaPos + 1);\n    const metaStr = uri.substring('data:'.length, commaPos);\n\n    let encoding;\n    const metaEntries = metaStr.split(';');\n\n    if (metaEntries.length > 0) {\n        const lastEntry = metaEntries[metaEntries.length - 1].toLowerCase().trim();\n        // Only recognize valid encoding types to prevent manipulation\n        if (['base64', 'utf8', 'utf-8'].includes(lastEntry) && lastEntry.indexOf('=') === -1) {\n            encoding = lastEntry;\n            metaEntries.pop();\n        }\n    }\n\n    const contentType = metaEntries.length > 0 ? metaEntries.shift() : 'application/octet-stream';\n    const params = {};\n\n    for (let i = 0; i < metaEntries.length; i++) {\n        const entry = metaEntries[i];\n        const sepPos = entry.indexOf('=');\n        if (sepPos > 0) {\n            // Ensure there's a key before the '='\n            const key = entry.substring(0, sepPos).trim();\n            const value = entry.substring(sepPos + 1).trim();\n            if (key) {\n                params[key] = value;\n            }\n        }\n    }\n\n    // Decode data based on encoding with proper error handling\n    let bufferData;\n    try {\n        if (encoding === 'base64') {\n            bufferData = Buffer.from(data, 'base64');\n        } else {\n            try {\n                bufferData = Buffer.from(decodeURIComponent(data));\n            } catch (_decodeError) {\n                bufferData = Buffer.from(data);\n            }\n        }\n    } catch (_bufferError) {\n        bufferData = Buffer.alloc(0);\n    }\n\n    return {\n        data: bufferData,\n        encoding: encoding || null,\n        contentType: contentType || 'application/octet-stream',\n        params\n    };\n};\n\n/**\n * Resolves a String or a Buffer value for content value. Useful if the value\n * is a Stream or a file or an URL. If the value is a Stream, overwrites\n * the stream object with the resolved value (you can't stream a value twice).\n *\n * This is useful when you want to create a plugin that needs a content value,\n * for example the `html` or `text` value as a String or a Buffer but not as\n * a file path or an URL.\n *\n * @param {Object} data An object or an Array you want to resolve an element for\n * @param {String|Number} key Property name or an Array index\n * @param {Function} callback Callback function with (err, value)\n */\nmodule.exports.resolveContent = (data, key, callback) => {\n    let promise;\n\n    if (!callback) {\n        promise = new Promise((resolve, reject) => {\n            callback = module.exports.callbackPromise(resolve, reject);\n        });\n    }\n\n    let content = (data && data[key] && data[key].content) || data[key];\n    let contentStream;\n    let encoding = ((typeof data[key] === 'object' && data[key].encoding) || 'utf8')\n        .toString()\n        .toLowerCase()\n        .replace(/[-_\\s]/g, '');\n\n    if (!content) {\n        return callback(null, content);\n    }\n\n    if (typeof content === 'object') {\n        if (typeof content.pipe === 'function') {\n            return resolveStream(content, (err, value) => {\n                if (err) {\n                    return callback(err);\n                }\n                // we can't stream twice the same content, so we need\n                // to replace the stream object with the streaming result\n                if (data[key].content) {\n                    data[key].content = value;\n                } else {\n                    data[key] = value;\n                }\n                callback(null, value);\n            });\n        } else if (/^https?:\\/\\//i.test(content.path || content.href)) {\n            contentStream = nmfetch(content.path || content.href);\n            return resolveStream(contentStream, callback);\n        } else if (/^data:/i.test(content.path || content.href)) {\n            let parsedDataUri = module.exports.parseDataURI(content.path || content.href);\n\n            if (!parsedDataUri || !parsedDataUri.data) {\n                return callback(null, Buffer.from(0));\n            }\n            return callback(null, parsedDataUri.data);\n        } else if (content.path) {\n            return resolveStream(fs.createReadStream(content.path), callback);\n        }\n    }\n\n    if (typeof data[key].content === 'string' && !['utf8', 'usascii', 'ascii'].includes(encoding)) {\n        content = Buffer.from(data[key].content, encoding);\n    }\n\n    // default action, return as is\n    setImmediate(() => callback(null, content));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nmodule.exports.assign = function (/* target, ... sources */) {\n    let args = Array.from(arguments);\n    let target = args.shift() || {};\n\n    args.forEach(source => {\n        Object.keys(source || {}).forEach(key => {\n            if (['tls', 'auth'].includes(key) && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // ensure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(subKey => {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n};\n\nmodule.exports.encodeXText = str => {\n    // ! 0x21\n    // + 0x2B\n    // = 0x3D\n    // ~ 0x7E\n    if (!/[^\\x21-\\x2A\\x2C-\\x3C\\x3E-\\x7E]/.test(str)) {\n        return str;\n    }\n    let buf = Buffer.from(str);\n    let result = '';\n    for (let i = 0, len = buf.length; i < len; i++) {\n        let c = buf[i];\n        if (c < 0x21 || c > 0x7e || c === 0x2b || c === 0x3d) {\n            result += '+' + (c < 0x10 ? '0' : '') + c.toString(16).toUpperCase();\n        } else {\n            result += String.fromCharCode(c);\n        }\n    }\n    return result;\n};\n\n/**\n * Streams a stream value into a Buffer\n *\n * @param {Object} stream Readable stream\n * @param {Function} callback Callback function with (err, value)\n */\nfunction resolveStream(stream, callback) {\n    let responded = false;\n    let chunks = [];\n    let chunklen = 0;\n\n    stream.on('error', err => {\n        if (responded) {\n            return;\n        }\n\n        responded = true;\n        callback(err);\n    });\n\n    stream.on('readable', () => {\n        let chunk;\n        while ((chunk = stream.read()) !== null) {\n            chunks.push(chunk);\n            chunklen += chunk.length;\n        }\n    });\n\n    stream.on('end', () => {\n        if (responded) {\n            return;\n        }\n        responded = true;\n\n        let value;\n\n        try {\n            value = Buffer.concat(chunks, chunklen);\n        } catch (E) {\n            return callback(E);\n        }\n        callback(null, value);\n    });\n}\n\n/**\n * Generates a bunyan-like logger that prints to console\n *\n * @returns {Object} Bunyan logger instance\n */\nfunction createDefaultLogger(levels) {\n    let levelMaxLen = 0;\n    let levelNames = new Map();\n    levels.forEach(level => {\n        if (level.length > levelMaxLen) {\n            levelMaxLen = level.length;\n        }\n    });\n\n    levels.forEach(level => {\n        let levelName = level.toUpperCase();\n        if (levelName.length < levelMaxLen) {\n            levelName += ' '.repeat(levelMaxLen - levelName.length);\n        }\n        levelNames.set(level, levelName);\n    });\n\n    let print = (level, entry, message, ...args) => {\n        let prefix = '';\n        if (entry) {\n            if (entry.tnx === 'server') {\n                prefix = 'S: ';\n            } else if (entry.tnx === 'client') {\n                prefix = 'C: ';\n            }\n\n            if (entry.sid) {\n                prefix = '[' + entry.sid + '] ' + prefix;\n            }\n\n            if (entry.cid) {\n                prefix = '[#' + entry.cid + '] ' + prefix;\n            }\n        }\n\n        message = util.format(message, ...args);\n        message.split(/\\r?\\n/).forEach(line => {\n            console.log('[%s] %s %s', new Date().toISOString().substr(0, 19).replace(/T/, ' '), levelNames.get(level), prefix + line);\n        });\n    };\n\n    let logger = {};\n    levels.forEach(level => {\n        logger[level] = print.bind(null, level);\n    });\n\n    return logger;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}