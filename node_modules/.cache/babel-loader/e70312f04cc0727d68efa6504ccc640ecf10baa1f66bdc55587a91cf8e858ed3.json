{"ast":null,"code":"'use strict';\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n  let isGroup = false;\n  let state = 'text';\n  let address;\n  let addresses = [];\n  let data = {\n    address: [],\n    comment: [],\n    group: [],\n    text: [],\n    textWasQuoted: [] // Track which text tokens came from inside quotes\n  };\n  let i;\n  let len;\n  let insideQuotes = false; // Track if we're currently inside a quoted string\n\n  // Filter out <addresses>, (comments) and regular text\n  for (i = 0, len = tokens.length; i < len; i++) {\n    let token = tokens[i];\n    let prevToken = i ? tokens[i - 1] : null;\n    if (token.type === 'operator') {\n      switch (token.value) {\n        case '<':\n          state = 'address';\n          insideQuotes = false;\n          break;\n        case '(':\n          state = 'comment';\n          insideQuotes = false;\n          break;\n        case ':':\n          state = 'group';\n          isGroup = true;\n          insideQuotes = false;\n          break;\n        case '\"':\n          // Track quote state for text tokens\n          insideQuotes = !insideQuotes;\n          state = 'text';\n          break;\n        default:\n          state = 'text';\n          insideQuotes = false;\n          break;\n      }\n    } else if (token.value) {\n      if (state === 'address') {\n        // handle use case where unquoted name includes a \"<\"\n        // Apple Mail truncates everything between an unexpected < and an address\n        // and so will we\n        token.value = token.value.replace(/^[^<]*<\\s*/, '');\n      }\n      if (prevToken && prevToken.noBreak && data[state].length) {\n        // join values\n        data[state][data[state].length - 1] += token.value;\n        if (state === 'text' && insideQuotes) {\n          data.textWasQuoted[data.textWasQuoted.length - 1] = true;\n        }\n      } else {\n        data[state].push(token.value);\n        if (state === 'text') {\n          data.textWasQuoted.push(insideQuotes);\n        }\n      }\n    }\n  }\n\n  // If there is no text but a comment, replace the two\n  if (!data.text.length && data.comment.length) {\n    data.text = data.comment;\n    data.comment = [];\n  }\n  if (isGroup) {\n    // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n    data.text = data.text.join(' ');\n\n    // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)\n    let groupMembers = [];\n    if (data.group.length) {\n      let parsedGroup = addressparser(data.group.join(','));\n      // Flatten: if any member is itself a group, extract its members into the sequence\n      parsedGroup.forEach(member => {\n        if (member.group) {\n          // Nested group detected - flatten it by adding its members directly\n          groupMembers = groupMembers.concat(member.group);\n        } else {\n          groupMembers.push(member);\n        }\n      });\n    }\n    addresses.push({\n      name: data.text || address && address.name,\n      group: groupMembers\n    });\n  } else {\n    // If no address was found, try to detect one from regular text\n    if (!data.address.length && data.text.length) {\n      for (i = data.text.length - 1; i >= 0; i--) {\n        // Security fix: Do not extract email addresses from quoted strings\n        // RFC 5321 allows @ inside quoted local-parts like \"user@domain\"@example.com\n        // Extracting emails from quoted text leads to misrouting vulnerabilities\n        if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n          data.address = data.text.splice(i, 1);\n          data.textWasQuoted.splice(i, 1);\n          break;\n        }\n      }\n      let _regexHandler = function (address) {\n        if (!data.address.length) {\n          data.address = [address.trim()];\n          return ' ';\n        } else {\n          return address;\n        }\n      };\n\n      // still no address\n      if (!data.address.length) {\n        for (i = data.text.length - 1; i >= 0; i--) {\n          // Security fix: Do not extract email addresses from quoted strings\n          if (!data.textWasQuoted[i]) {\n            // fixed the regex to parse email address correctly when email address has more than one @\n            data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n            if (data.address.length) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // If there's still is no text but a comment exixts, replace the two\n    if (!data.text.length && data.comment.length) {\n      data.text = data.comment;\n      data.comment = [];\n    }\n\n    // Keep only the first address occurence, push others to regular text\n    if (data.address.length > 1) {\n      data.text = data.text.concat(data.address.splice(1));\n    }\n\n    // Join values with spaces\n    data.text = data.text.join(' ');\n    data.address = data.address.join(' ');\n    if (!data.address && isGroup) {\n      return [];\n    } else {\n      address = {\n        address: data.address || data.text || '',\n        name: data.text || data.address || ''\n      };\n      if (address.address === address.name) {\n        if ((address.address || '').match(/@/)) {\n          address.name = '';\n        } else {\n          address.address = '';\n        }\n      }\n      addresses.push(address);\n    }\n  }\n  return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n  constructor(str) {\n    this.str = (str || '').toString();\n    this.operatorCurrent = '';\n    this.operatorExpecting = '';\n    this.node = null;\n    this.escaped = false;\n    this.list = [];\n    /**\n     * Operator tokens and which tokens are expected to end the sequence\n     */\n    this.operators = {\n      '\"': '\"',\n      '(': ')',\n      '<': '>',\n      ',': '',\n      ':': ';',\n      // Semicolons are not a legal delimiter per the RFC2822 grammar other\n      // than for terminating a group, but they are also not valid for any\n      // other use in this context.  Given that some mail clients have\n      // historically allowed the semicolon as a delimiter equivalent to the\n      // comma in their UI, it makes sense to treat them the same as a comma\n      // when used outside of a group.\n      ';': ''\n    };\n  }\n\n  /**\n   * Tokenizes the original input string\n   *\n   * @return {Array} An array of operator|text tokens\n   */\n  tokenize() {\n    let list = [];\n    for (let i = 0, len = this.str.length; i < len; i++) {\n      let chr = this.str.charAt(i);\n      let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;\n      this.checkChar(chr, nextChr);\n    }\n    this.list.forEach(node => {\n      node.value = (node.value || '').toString().trim();\n      if (node.value) {\n        list.push(node);\n      }\n    });\n    return list;\n  }\n\n  /**\n   * Checks if a character is an operator or text and acts accordingly\n   *\n   * @param {String} chr Character from the address field\n   */\n  checkChar(chr, nextChr) {\n    if (this.escaped) {\n      // ignore next condition blocks\n    } else if (chr === this.operatorExpecting) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      };\n      if (nextChr && ![' ', '\\t', '\\r', '\\n', ',', ';'].includes(nextChr)) {\n        this.node.noBreak = true;\n      }\n      this.list.push(this.node);\n      this.node = null;\n      this.operatorExpecting = '';\n      this.escaped = false;\n      return;\n    } else if (!this.operatorExpecting && chr in this.operators) {\n      this.node = {\n        type: 'operator',\n        value: chr\n      };\n      this.list.push(this.node);\n      this.node = null;\n      this.operatorExpecting = this.operators[chr];\n      this.escaped = false;\n      return;\n    } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n      this.escaped = true;\n      return;\n    }\n    if (!this.node) {\n      this.node = {\n        type: 'text',\n        value: ''\n      };\n      this.list.push(this.node);\n    }\n    if (chr === '\\n') {\n      // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n      // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n      chr = ' ';\n    }\n    if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n      // skip command bytes\n      this.node.value += chr;\n    }\n    this.escaped = false;\n  }\n}\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n  options = options || {};\n  let tokenizer = new Tokenizer(str);\n  let tokens = tokenizer.tokenize();\n  let addresses = [];\n  let address = [];\n  let parsedAddresses = [];\n  tokens.forEach(token => {\n    if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n      if (address.length) {\n        addresses.push(address);\n      }\n      address = [];\n    } else {\n      address.push(token);\n    }\n  });\n  if (address.length) {\n    addresses.push(address);\n  }\n  addresses.forEach(address => {\n    address = _handleAddress(address);\n    if (address.length) {\n      parsedAddresses = parsedAddresses.concat(address);\n    }\n  });\n  if (options.flatten) {\n    let addresses = [];\n    let walkAddressList = list => {\n      list.forEach(address => {\n        if (address.group) {\n          return walkAddressList(address.group);\n        } else {\n          addresses.push(address);\n        }\n      });\n    };\n    walkAddressList(parsedAddresses);\n    return addresses;\n  }\n  return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;","map":{"version":3,"names":["_handleAddress","tokens","isGroup","state","address","addresses","data","comment","group","text","textWasQuoted","i","len","insideQuotes","length","token","prevToken","type","value","replace","noBreak","push","join","groupMembers","parsedGroup","addressparser","forEach","member","concat","name","match","splice","_regexHandler","trim","Tokenizer","constructor","str","toString","operatorCurrent","operatorExpecting","node","escaped","list","operators","tokenize","chr","charAt","nextChr","checkChar","includes","charCodeAt","options","tokenizer","parsedAddresses","flatten","walkAddressList","module","exports"],"sources":["D:/bank/banking-finance-system/node_modules/nodemailer/lib/addressparser/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @return {Object} Address object\n */\nfunction _handleAddress(tokens) {\n    let isGroup = false;\n    let state = 'text';\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: [],\n        textWasQuoted: [] // Track which text tokens came from inside quotes\n    };\n    let i;\n    let len;\n    let insideQuotes = false; // Track if we're currently inside a quoted string\n\n    // Filter out <addresses>, (comments) and regular text\n    for (i = 0, len = tokens.length; i < len; i++) {\n        let token = tokens[i];\n        let prevToken = i ? tokens[i - 1] : null;\n        if (token.type === 'operator') {\n            switch (token.value) {\n                case '<':\n                    state = 'address';\n                    insideQuotes = false;\n                    break;\n                case '(':\n                    state = 'comment';\n                    insideQuotes = false;\n                    break;\n                case ':':\n                    state = 'group';\n                    isGroup = true;\n                    insideQuotes = false;\n                    break;\n                case '\"':\n                    // Track quote state for text tokens\n                    insideQuotes = !insideQuotes;\n                    state = 'text';\n                    break;\n                default:\n                    state = 'text';\n                    insideQuotes = false;\n                    break;\n            }\n        } else if (token.value) {\n            if (state === 'address') {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, '');\n            }\n\n            if (prevToken && prevToken.noBreak && data[state].length) {\n                // join values\n                data[state][data[state].length - 1] += token.value;\n                if (state === 'text' && insideQuotes) {\n                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;\n                }\n            } else {\n                data[state].push(token.value);\n                if (state === 'text') {\n                    data.textWasQuoted.push(insideQuotes);\n                }\n            }\n        }\n    }\n\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(' ');\n\n        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)\n        let groupMembers = [];\n        if (data.group.length) {\n            let parsedGroup = addressparser(data.group.join(','));\n            // Flatten: if any member is itself a group, extract its members into the sequence\n            parsedGroup.forEach(member => {\n                if (member.group) {\n                    // Nested group detected - flatten it by adding its members directly\n                    groupMembers = groupMembers.concat(member.group);\n                } else {\n                    groupMembers.push(member);\n                }\n            });\n        }\n\n        addresses.push({\n            name: data.text || (address && address.name),\n            group: groupMembers\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for (i = data.text.length - 1; i >= 0; i--) {\n                // Security fix: Do not extract email addresses from quoted strings\n                // RFC 5321 allows @ inside quoted local-parts like \"user@domain\"@example.com\n                // Extracting emails from quoted text leads to misrouting vulnerabilities\n                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    data.textWasQuoted.splice(i, 1);\n                    break;\n                }\n            }\n\n            let _regexHandler = function (address) {\n                if (!data.address.length) {\n                    data.address = [address.trim()];\n                    return ' ';\n                } else {\n                    return address;\n                }\n            };\n\n            // still no address\n            if (!data.address.length) {\n                for (i = data.text.length - 1; i >= 0; i--) {\n                    // Security fix: Do not extract email addresses from quoted strings\n                    if (!data.textWasQuoted[i]) {\n                        // fixed the regex to parse email address correctly when email address has more than one @\n                        data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                        if (data.address.length) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n\n        // Join values with spaces\n        data.text = data.text.join(' ');\n        data.address = data.address.join(' ');\n\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || '',\n                name: data.text || data.address || ''\n            };\n\n            if (address.address === address.name) {\n                if ((address.address || '').match(/@/)) {\n                    address.name = '';\n                } else {\n                    address.address = '';\n                }\n            }\n\n            addresses.push(address);\n        }\n    }\n\n    return addresses;\n}\n\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */\nclass Tokenizer {\n    constructor(str) {\n        this.str = (str || '').toString();\n        this.operatorCurrent = '';\n        this.operatorExpecting = '';\n        this.node = null;\n        this.escaped = false;\n\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */\n        this.operators = {\n            '\"': '\"',\n            '(': ')',\n            '<': '>',\n            ',': '',\n            ':': ';',\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            ';': ''\n        };\n    }\n\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */\n    tokenize() {\n        let list = [];\n\n        for (let i = 0, len = this.str.length; i < len; i++) {\n            let chr = this.str.charAt(i);\n            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;\n            this.checkChar(chr, nextChr);\n        }\n\n        this.list.forEach(node => {\n            node.value = (node.value || '').toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n\n        return list;\n    }\n\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */\n    checkChar(chr, nextChr) {\n        if (this.escaped) {\n            // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n\n            if (nextChr && ![' ', '\\t', '\\r', '\\n', ',', ';'].includes(nextChr)) {\n                this.node.noBreak = true;\n            }\n\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = '';\n            this.escaped = false;\n\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: 'operator',\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if (['\"', \"'\"].includes(this.operatorExpecting) && chr === '\\\\') {\n            this.escaped = true;\n            return;\n        }\n\n        if (!this.node) {\n            this.node = {\n                type: 'text',\n                value: ''\n            };\n            this.list.push(this.node);\n        }\n\n        if (chr === '\\n') {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = ' ';\n        }\n\n        if (chr.charCodeAt(0) >= 0x21 || [' ', '\\t'].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n\n        this.escaped = false;\n    }\n}\n\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @return {Array} An array of address objects\n */\nfunction addressparser(str, options) {\n    options = options || {};\n\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n\n    tokens.forEach(token => {\n        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n\n    if (address.length) {\n        addresses.push(address);\n    }\n\n    addresses.forEach(address => {\n        address = _handleAddress(address);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = list => {\n            list.forEach(address => {\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n\n    return parsedAddresses;\n}\n\n// expose to the world\nmodule.exports = addressparser;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,cAAcA,CAACC,MAAM,EAAE;EAC5B,IAAIC,OAAO,GAAG,KAAK;EACnB,IAAIC,KAAK,GAAG,MAAM;EAClB,IAAIC,OAAO;EACX,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAIC,IAAI,GAAG;IACPF,OAAO,EAAE,EAAE;IACXG,OAAO,EAAE,EAAE;IACXC,KAAK,EAAE,EAAE;IACTC,IAAI,EAAE,EAAE;IACRC,aAAa,EAAE,EAAE,CAAC;EACtB,CAAC;EACD,IAAIC,CAAC;EACL,IAAIC,GAAG;EACP,IAAIC,YAAY,GAAG,KAAK,CAAC,CAAC;;EAE1B;EACA,KAAKF,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGX,MAAM,CAACa,MAAM,EAAEH,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAC3C,IAAII,KAAK,GAAGd,MAAM,CAACU,CAAC,CAAC;IACrB,IAAIK,SAAS,GAAGL,CAAC,GAAGV,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI;IACxC,IAAII,KAAK,CAACE,IAAI,KAAK,UAAU,EAAE;MAC3B,QAAQF,KAAK,CAACG,KAAK;QACf,KAAK,GAAG;UACJf,KAAK,GAAG,SAAS;UACjBU,YAAY,GAAG,KAAK;UACpB;QACJ,KAAK,GAAG;UACJV,KAAK,GAAG,SAAS;UACjBU,YAAY,GAAG,KAAK;UACpB;QACJ,KAAK,GAAG;UACJV,KAAK,GAAG,OAAO;UACfD,OAAO,GAAG,IAAI;UACdW,YAAY,GAAG,KAAK;UACpB;QACJ,KAAK,GAAG;UACJ;UACAA,YAAY,GAAG,CAACA,YAAY;UAC5BV,KAAK,GAAG,MAAM;UACd;QACJ;UACIA,KAAK,GAAG,MAAM;UACdU,YAAY,GAAG,KAAK;UACpB;MACR;IACJ,CAAC,MAAM,IAAIE,KAAK,CAACG,KAAK,EAAE;MACpB,IAAIf,KAAK,KAAK,SAAS,EAAE;QACrB;QACA;QACA;QACAY,KAAK,CAACG,KAAK,GAAGH,KAAK,CAACG,KAAK,CAACC,OAAO,CAAC,YAAY,EAAE,EAAE,CAAC;MACvD;MAEA,IAAIH,SAAS,IAAIA,SAAS,CAACI,OAAO,IAAId,IAAI,CAACH,KAAK,CAAC,CAACW,MAAM,EAAE;QACtD;QACAR,IAAI,CAACH,KAAK,CAAC,CAACG,IAAI,CAACH,KAAK,CAAC,CAACW,MAAM,GAAG,CAAC,CAAC,IAAIC,KAAK,CAACG,KAAK;QAClD,IAAIf,KAAK,KAAK,MAAM,IAAIU,YAAY,EAAE;UAClCP,IAAI,CAACI,aAAa,CAACJ,IAAI,CAACI,aAAa,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI;QAC5D;MACJ,CAAC,MAAM;QACHR,IAAI,CAACH,KAAK,CAAC,CAACkB,IAAI,CAACN,KAAK,CAACG,KAAK,CAAC;QAC7B,IAAIf,KAAK,KAAK,MAAM,EAAE;UAClBG,IAAI,CAACI,aAAa,CAACW,IAAI,CAACR,YAAY,CAAC;QACzC;MACJ;IACJ;EACJ;;EAEA;EACA,IAAI,CAACP,IAAI,CAACG,IAAI,CAACK,MAAM,IAAIR,IAAI,CAACC,OAAO,CAACO,MAAM,EAAE;IAC1CR,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACC,OAAO;IACxBD,IAAI,CAACC,OAAO,GAAG,EAAE;EACrB;EAEA,IAAIL,OAAO,EAAE;IACT;IACAI,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACG,IAAI,CAACa,IAAI,CAAC,GAAG,CAAC;;IAE/B;IACA,IAAIC,YAAY,GAAG,EAAE;IACrB,IAAIjB,IAAI,CAACE,KAAK,CAACM,MAAM,EAAE;MACnB,IAAIU,WAAW,GAAGC,aAAa,CAACnB,IAAI,CAACE,KAAK,CAACc,IAAI,CAAC,GAAG,CAAC,CAAC;MACrD;MACAE,WAAW,CAACE,OAAO,CAACC,MAAM,IAAI;QAC1B,IAAIA,MAAM,CAACnB,KAAK,EAAE;UACd;UACAe,YAAY,GAAGA,YAAY,CAACK,MAAM,CAACD,MAAM,CAACnB,KAAK,CAAC;QACpD,CAAC,MAAM;UACHe,YAAY,CAACF,IAAI,CAACM,MAAM,CAAC;QAC7B;MACJ,CAAC,CAAC;IACN;IAEAtB,SAAS,CAACgB,IAAI,CAAC;MACXQ,IAAI,EAAEvB,IAAI,CAACG,IAAI,IAAKL,OAAO,IAAIA,OAAO,CAACyB,IAAK;MAC5CrB,KAAK,EAAEe;IACX,CAAC,CAAC;EACN,CAAC,MAAM;IACH;IACA,IAAI,CAACjB,IAAI,CAACF,OAAO,CAACU,MAAM,IAAIR,IAAI,CAACG,IAAI,CAACK,MAAM,EAAE;MAC1C,KAAKH,CAAC,GAAGL,IAAI,CAACG,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEH,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxC;QACA;QACA;QACA,IAAI,CAACL,IAAI,CAACI,aAAa,CAACC,CAAC,CAAC,IAAIL,IAAI,CAACG,IAAI,CAACE,CAAC,CAAC,CAACmB,KAAK,CAAC,mBAAmB,CAAC,EAAE;UACnExB,IAAI,CAACF,OAAO,GAAGE,IAAI,CAACG,IAAI,CAACsB,MAAM,CAACpB,CAAC,EAAE,CAAC,CAAC;UACrCL,IAAI,CAACI,aAAa,CAACqB,MAAM,CAACpB,CAAC,EAAE,CAAC,CAAC;UAC/B;QACJ;MACJ;MAEA,IAAIqB,aAAa,GAAG,SAAAA,CAAU5B,OAAO,EAAE;QACnC,IAAI,CAACE,IAAI,CAACF,OAAO,CAACU,MAAM,EAAE;UACtBR,IAAI,CAACF,OAAO,GAAG,CAACA,OAAO,CAAC6B,IAAI,CAAC,CAAC,CAAC;UAC/B,OAAO,GAAG;QACd,CAAC,MAAM;UACH,OAAO7B,OAAO;QAClB;MACJ,CAAC;;MAED;MACA,IAAI,CAACE,IAAI,CAACF,OAAO,CAACU,MAAM,EAAE;QACtB,KAAKH,CAAC,GAAGL,IAAI,CAACG,IAAI,CAACK,MAAM,GAAG,CAAC,EAAEH,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;UACxC;UACA,IAAI,CAACL,IAAI,CAACI,aAAa,CAACC,CAAC,CAAC,EAAE;YACxB;YACAL,IAAI,CAACG,IAAI,CAACE,CAAC,CAAC,GAAGL,IAAI,CAACG,IAAI,CAACE,CAAC,CAAC,CAACQ,OAAO,CAAC,0BAA0B,EAAEa,aAAa,CAAC,CAACC,IAAI,CAAC,CAAC;YACrF,IAAI3B,IAAI,CAACF,OAAO,CAACU,MAAM,EAAE;cACrB;YACJ;UACJ;QACJ;MACJ;IACJ;;IAEA;IACA,IAAI,CAACR,IAAI,CAACG,IAAI,CAACK,MAAM,IAAIR,IAAI,CAACC,OAAO,CAACO,MAAM,EAAE;MAC1CR,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACC,OAAO;MACxBD,IAAI,CAACC,OAAO,GAAG,EAAE;IACrB;;IAEA;IACA,IAAID,IAAI,CAACF,OAAO,CAACU,MAAM,GAAG,CAAC,EAAE;MACzBR,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACG,IAAI,CAACmB,MAAM,CAACtB,IAAI,CAACF,OAAO,CAAC2B,MAAM,CAAC,CAAC,CAAC,CAAC;IACxD;;IAEA;IACAzB,IAAI,CAACG,IAAI,GAAGH,IAAI,CAACG,IAAI,CAACa,IAAI,CAAC,GAAG,CAAC;IAC/BhB,IAAI,CAACF,OAAO,GAAGE,IAAI,CAACF,OAAO,CAACkB,IAAI,CAAC,GAAG,CAAC;IAErC,IAAI,CAAChB,IAAI,CAACF,OAAO,IAAIF,OAAO,EAAE;MAC1B,OAAO,EAAE;IACb,CAAC,MAAM;MACHE,OAAO,GAAG;QACNA,OAAO,EAAEE,IAAI,CAACF,OAAO,IAAIE,IAAI,CAACG,IAAI,IAAI,EAAE;QACxCoB,IAAI,EAAEvB,IAAI,CAACG,IAAI,IAAIH,IAAI,CAACF,OAAO,IAAI;MACvC,CAAC;MAED,IAAIA,OAAO,CAACA,OAAO,KAAKA,OAAO,CAACyB,IAAI,EAAE;QAClC,IAAI,CAACzB,OAAO,CAACA,OAAO,IAAI,EAAE,EAAE0B,KAAK,CAAC,GAAG,CAAC,EAAE;UACpC1B,OAAO,CAACyB,IAAI,GAAG,EAAE;QACrB,CAAC,MAAM;UACHzB,OAAO,CAACA,OAAO,GAAG,EAAE;QACxB;MACJ;MAEAC,SAAS,CAACgB,IAAI,CAACjB,OAAO,CAAC;IAC3B;EACJ;EAEA,OAAOC,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM6B,SAAS,CAAC;EACZC,WAAWA,CAACC,GAAG,EAAE;IACb,IAAI,CAACA,GAAG,GAAG,CAACA,GAAG,IAAI,EAAE,EAAEC,QAAQ,CAAC,CAAC;IACjC,IAAI,CAACC,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB,IAAI,CAACC,OAAO,GAAG,KAAK;IAEpB,IAAI,CAACC,IAAI,GAAG,EAAE;IACd;AACR;AACA;IACQ,IAAI,CAACC,SAAS,GAAG;MACb,GAAG,EAAE,GAAG;MACR,GAAG,EAAE,GAAG;MACR,GAAG,EAAE,GAAG;MACR,GAAG,EAAE,EAAE;MACP,GAAG,EAAE,GAAG;MACR;MACA;MACA;MACA;MACA;MACA;MACA,GAAG,EAAE;IACT,CAAC;EACL;;EAEA;AACJ;AACA;AACA;AACA;EACIC,QAAQA,CAAA,EAAG;IACP,IAAIF,IAAI,GAAG,EAAE;IAEb,KAAK,IAAI/B,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACwB,GAAG,CAACtB,MAAM,EAAEH,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACjD,IAAIkC,GAAG,GAAG,IAAI,CAACT,GAAG,CAACU,MAAM,CAACnC,CAAC,CAAC;MAC5B,IAAIoC,OAAO,GAAGpC,CAAC,GAAGC,GAAG,GAAG,CAAC,GAAG,IAAI,CAACwB,GAAG,CAACU,MAAM,CAACnC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI;MACzD,IAAI,CAACqC,SAAS,CAACH,GAAG,EAAEE,OAAO,CAAC;IAChC;IAEA,IAAI,CAACL,IAAI,CAAChB,OAAO,CAACc,IAAI,IAAI;MACtBA,IAAI,CAACtB,KAAK,GAAG,CAACsB,IAAI,CAACtB,KAAK,IAAI,EAAE,EAAEmB,QAAQ,CAAC,CAAC,CAACJ,IAAI,CAAC,CAAC;MACjD,IAAIO,IAAI,CAACtB,KAAK,EAAE;QACZwB,IAAI,CAACrB,IAAI,CAACmB,IAAI,CAAC;MACnB;IACJ,CAAC,CAAC;IAEF,OAAOE,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;EACIM,SAASA,CAACH,GAAG,EAAEE,OAAO,EAAE;IACpB,IAAI,IAAI,CAACN,OAAO,EAAE;MACd;IAAA,CACH,MAAM,IAAII,GAAG,KAAK,IAAI,CAACN,iBAAiB,EAAE;MACvC,IAAI,CAACC,IAAI,GAAG;QACRvB,IAAI,EAAE,UAAU;QAChBC,KAAK,EAAE2B;MACX,CAAC;MAED,IAAIE,OAAO,IAAI,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAACE,QAAQ,CAACF,OAAO,CAAC,EAAE;QACjE,IAAI,CAACP,IAAI,CAACpB,OAAO,GAAG,IAAI;MAC5B;MAEA,IAAI,CAACsB,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACmB,IAAI,CAAC;MACzB,IAAI,CAACA,IAAI,GAAG,IAAI;MAChB,IAAI,CAACD,iBAAiB,GAAG,EAAE;MAC3B,IAAI,CAACE,OAAO,GAAG,KAAK;MAEpB;IACJ,CAAC,MAAM,IAAI,CAAC,IAAI,CAACF,iBAAiB,IAAIM,GAAG,IAAI,IAAI,CAACF,SAAS,EAAE;MACzD,IAAI,CAACH,IAAI,GAAG;QACRvB,IAAI,EAAE,UAAU;QAChBC,KAAK,EAAE2B;MACX,CAAC;MACD,IAAI,CAACH,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACmB,IAAI,CAAC;MACzB,IAAI,CAACA,IAAI,GAAG,IAAI;MAChB,IAAI,CAACD,iBAAiB,GAAG,IAAI,CAACI,SAAS,CAACE,GAAG,CAAC;MAC5C,IAAI,CAACJ,OAAO,GAAG,KAAK;MACpB;IACJ,CAAC,MAAM,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAACQ,QAAQ,CAAC,IAAI,CAACV,iBAAiB,CAAC,IAAIM,GAAG,KAAK,IAAI,EAAE;MACpE,IAAI,CAACJ,OAAO,GAAG,IAAI;MACnB;IACJ;IAEA,IAAI,CAAC,IAAI,CAACD,IAAI,EAAE;MACZ,IAAI,CAACA,IAAI,GAAG;QACRvB,IAAI,EAAE,MAAM;QACZC,KAAK,EAAE;MACX,CAAC;MACD,IAAI,CAACwB,IAAI,CAACrB,IAAI,CAAC,IAAI,CAACmB,IAAI,CAAC;IAC7B;IAEA,IAAIK,GAAG,KAAK,IAAI,EAAE;MACd;MACA;MACAA,GAAG,GAAG,GAAG;IACb;IAEA,IAAIA,GAAG,CAACK,UAAU,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAACD,QAAQ,CAACJ,GAAG,CAAC,EAAE;MACxD;MACA,IAAI,CAACL,IAAI,CAACtB,KAAK,IAAI2B,GAAG;IAC1B;IAEA,IAAI,CAACJ,OAAO,GAAG,KAAK;EACxB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShB,aAAaA,CAACW,GAAG,EAAEe,OAAO,EAAE;EACjCA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIC,SAAS,GAAG,IAAIlB,SAAS,CAACE,GAAG,CAAC;EAClC,IAAInC,MAAM,GAAGmD,SAAS,CAACR,QAAQ,CAAC,CAAC;EAEjC,IAAIvC,SAAS,GAAG,EAAE;EAClB,IAAID,OAAO,GAAG,EAAE;EAChB,IAAIiD,eAAe,GAAG,EAAE;EAExBpD,MAAM,CAACyB,OAAO,CAACX,KAAK,IAAI;IACpB,IAAIA,KAAK,CAACE,IAAI,KAAK,UAAU,KAAKF,KAAK,CAACG,KAAK,KAAK,GAAG,IAAIH,KAAK,CAACG,KAAK,KAAK,GAAG,CAAC,EAAE;MAC3E,IAAId,OAAO,CAACU,MAAM,EAAE;QAChBT,SAAS,CAACgB,IAAI,CAACjB,OAAO,CAAC;MAC3B;MACAA,OAAO,GAAG,EAAE;IAChB,CAAC,MAAM;MACHA,OAAO,CAACiB,IAAI,CAACN,KAAK,CAAC;IACvB;EACJ,CAAC,CAAC;EAEF,IAAIX,OAAO,CAACU,MAAM,EAAE;IAChBT,SAAS,CAACgB,IAAI,CAACjB,OAAO,CAAC;EAC3B;EAEAC,SAAS,CAACqB,OAAO,CAACtB,OAAO,IAAI;IACzBA,OAAO,GAAGJ,cAAc,CAACI,OAAO,CAAC;IACjC,IAAIA,OAAO,CAACU,MAAM,EAAE;MAChBuC,eAAe,GAAGA,eAAe,CAACzB,MAAM,CAACxB,OAAO,CAAC;IACrD;EACJ,CAAC,CAAC;EAEF,IAAI+C,OAAO,CAACG,OAAO,EAAE;IACjB,IAAIjD,SAAS,GAAG,EAAE;IAClB,IAAIkD,eAAe,GAAGb,IAAI,IAAI;MAC1BA,IAAI,CAAChB,OAAO,CAACtB,OAAO,IAAI;QACpB,IAAIA,OAAO,CAACI,KAAK,EAAE;UACf,OAAO+C,eAAe,CAACnD,OAAO,CAACI,KAAK,CAAC;QACzC,CAAC,MAAM;UACHH,SAAS,CAACgB,IAAI,CAACjB,OAAO,CAAC;QAC3B;MACJ,CAAC,CAAC;IACN,CAAC;IACDmD,eAAe,CAACF,eAAe,CAAC;IAChC,OAAOhD,SAAS;EACpB;EAEA,OAAOgD,eAAe;AAC1B;;AAEA;AACAG,MAAM,CAACC,OAAO,GAAGhC,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}